<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 规约 | Hedley]]></title>
  <link href="http://hedleyyan.github.io/tags/gui-yue/atom.xml" rel="self"/>
  <link href="http://hedleyyan.github.io/"/>
  <updated>2015-05-17T21:21:12+08:00</updated>
  <id>http://hedleyyan.github.io/</id>
  <author>
    <name><![CDATA[dL]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Glossary of Name Reuse]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse/"/>
    <updated>2015-05-16T17:07:57+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>此文大概就是《Java Puzzlers》中Classier Pazzlers一节的简单翻译和整理，粗略总结了Java有关<strong>命名重复</strong>的场景和代码示例。</p>

<!--more-->


<h2>Overriding</h2>

<p><blockquote><p>An instance method overrides all accessible instance methods with the same signature in superclasses.</p><footer><strong>JLS 8.4.8.1</strong></footer></blockquote></p>

<p>重写的规范定义包括：</p>

<ul>
<li>Context包括两个类，一个子类，一个父类。</li>
<li>载体必须是实例方法(instance methods)，而非静态方法。</li>
<li>必须是同样签名(signature)，包括参数、返回类型。</li>
<li>重写方法不能缩小可见范围。</li>
</ul>


<p>重写是面向对象编程的核心概念，是<strong>唯一</strong>鼓励使用的Name Reuse场景。</p>

<pre><code class="java">    class Base {
        protected void f() { }
    }

    class Derived extends Base {
        public void f() { } // overrrides Base.f()
    }
</code></pre>

<h2>Overloading</h2>

<p><blockquote><p>Methods in a class overload one another if they have the same name and different signatures.</p><footer><strong>JLS 8.4.9</strong></footer></blockquote></p>

<p>重载和重写是Name Reuse出现最多的场景。相对于重写，重载规范包括：</p>

<ul>
<li>Context只有一个类。</li>
<li>载体可以是实例方法，也可以是静态方法。</li>
<li>拥有不同的签名。

<ul>
<li>但不能是参数相同，返回类型不同。</li>
</ul>
</li>
</ul>


<pre><code class="java">    class CircuitBreaker {
        public void f(int i)    { }  // int overloading
        public void f(String s) { }  // String overloading
    } 
</code></pre>

<h2>Hiding</h2>

<p><blockquote><p>A field, static method, or member type hides all accessible fields, static methods, or member types, respectively, with the same name (or, for methods, signature) in supertypes. Hiding a member prevents it from being inherited.</p><footer><strong>JLS 8.3-8.5</strong></footer></blockquote></p>

<p>Hiding和重载场景比较像，重载的载体是实例方法，而Hiding的载体是除去实例方法以外的其他所有元素。</p>

<ul>
<li>Context包括子类和父类。</li>
<li>载体包括属性、静态方法、成员类。</li>
<li>同样签名。</li>
<li>可见范围无约束。</li>
</ul>


<pre><code class="java">    class Base {
        public String className = "Base";
    }

    class Derived extends Base {
        private String className = "Derived";
    }

    public class PrivateMatter {
        public static void main(String[] args) {
            System.out.println(new Derived().className);
        }
    }
</code></pre>

<p>⬆️️️⬆️️️代码结果⬇️⬇️
<code>
PrivateMatter.java:11: className has private access in Derived
           System.out.println(new Derived().className);
</code>
很明显，Hiding的代码是晦涩难懂的，更重要的是它破坏了Liskov替换原则。应极力避免这种Name Reuse场景。</p>

<p><blockquote><p>Everything you can do with a base class, you can also do with a derived class.</p><footer><strong>Liskov Substitution Principle</strong></footer></blockquote></p>

<h2>Shadowing</h2>

<p><blockquote><p>A variable, method, or type shadows all variables, methods, or types, respectively, with the same name in a textually enclosing scope.</p><footer><strong>JLS 6.3.1</strong></footer></blockquote></p>

<ul>
<li>Context可能只有一个类，也可能包括别的函数库的类。</li>
<li>载体包括变量、方法和类。</li>
</ul>


<pre><code class="java">    class WhoKnows {
        static String sentence = "I don’t know.";
        public static void main(String[] args) {
            String sentence = "I know!";   // shadows static field
            System.out.println(sentence);  // prints local variable
        }
    }
</code></pre>

<pre><code class="java">public class StrungOut {
       public static void main(String[] args) {
           String s = new String("Hello world");
           System.out.println(s);
       }
}

class String {
        private final java.lang.String s;
        public String(java.lang.String s) {
            this.s = s;
        }
        public java.lang.String toString() {
            return s;
        } 
}
</code></pre>

<p>⬆️️️⬆️️️代码结果⬇️⬇️
<code>
Exception in thread "main" java.lang.NoSuchMethodError: main
</code></p>

<p>产生Shadowing场景的Name Reuse，依最近的作用域来判定是哪个元素有效。</p>

<h2>Obscuring</h2>

<p>Obscuring是指在作用域中，一个变量的名字和一个类相同，直接看示例代码。
<code>java
    public class Obscure {
        static String System; // Obscures type java.lang.System
        public static void main(String[] args) {
            // Next line won’t compile:
            System refers to static field System.out.println("hello, obscure world!");
        }
    }
</code></p>

<p><blockquote><p>If a type or a package is obscured, you cannot refer to it by its simple name except in a context where the syntax allows only a name from its namespace.</p></blockquote></p>

<h2>常见陷阱</h2>

<h2>总结</h2>

<ol>
<li>除了Override，尽量避免Name Reuse。</li>
<li>遵守Java命名规则，可以避免Obscuring。</li>
</ol>


<!--链接-->

]]></content>
  </entry>
  
</feed>
