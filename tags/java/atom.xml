<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Java | Hedley]]></title>
  <link href="http://hedleyyan.github.io/tags/java/atom.xml" rel="self"/>
  <link href="http://hedleyyan.github.io/"/>
  <updated>2015-06-05T14:12:31+08:00</updated>
  <id>http://hedleyyan.github.io/</id>
  <author>
    <name><![CDATA[dL]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[荒谬痛苦的嵌套类]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/05/huang-miu-tong-ku-de-nei-bu-lei/"/>
    <updated>2015-06-05T11:25:38+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/05/huang-miu-tong-ku-de-nei-bu-lei</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>此文简单总结嵌套类 (Nested Class) 的使用场景与一般建议：能使用<strong>静态嵌套类</strong> (Static Nested Class) 的时候就不用<strong>内部类</strong> (Inner Class)。</p>

<p><blockquote><p>A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class.</p></blockquote></p>

<!--more-->


<h2>分类</h2>

<h5>按定义位置</h5>

<ul>
<li>成员嵌套类 (Member Nested Class) : 作为外部类 (Enclosing Class) 的成员定义的，成员嵌套类有 Enclosing Class 的属性。

<ul>
<li>可以使用 public 等访问控制符，也可以用 static、 final 关键字。</li>
</ul>
</li>
<li>局部嵌套类 (Local Nested Class) : 局部嵌套类定义在 Enclosing Class 的方法里面，局部嵌套类有 Enclosing Class 的属性和外部方法 (Enclosing Method) 的属性。

<ul>
<li>可以使用final关键字。</li>
</ul>
</li>
<li>匿名嵌套类 (Anonymous Nested Class) : 匿名嵌套类没有显示的定义一个类，直接通过 <code>new</code> 的方法创建类的实例。

<ul>
<li>不使用任何关键字和访问控制符。</li>
</ul>
</li>
</ul>


<h5>按功能</h5>

<p>大多数情况下，嵌套类都按功能分：</p>

<ul>
<li>静态嵌套类 (Static Nested Class) : static 修饰的<strong>成员嵌套类</strong>。</li>
<li>内部类 (Inner Class) : 静态嵌套类之外所有的嵌套类的总称。

<ul>
<li>内部类不能定义为 static，不能有 static 方法和 static 初始化语句块。</li>
</ul>
</li>
</ul>


<p>所以，局部嵌套类和匿名嵌套类肯定是内部类，成员嵌套类则分为静态和非静态的。</p>

<p><blockquote><p>An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers or member interfaces.</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Glossary of Name Reuse]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse/"/>
    <updated>2015-05-16T17:07:57+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse</id>
    <content type="html"><![CDATA[<h2>关于</h2>

<p>此文大概就是《Java Puzzlers》中 Classier Pazzlers 一节的简单翻译和整理，粗略总结了 Java 有关<strong>命名重复</strong>的场景和代码示例。</p>

<!--more-->


<h2>Overriding</h2>

<p><blockquote><p>An instance method overrides all accessible instance methods with the same signature in superclasses.</p><footer><strong>JLS 8.4.8.1</strong></footer></blockquote></p>

<p>重写的规范定义包括：</p>

<ul>
<li>Context 包括两个类，一个子类，一个父类。</li>
<li>载体必须是实例方法 (instance methods)，而非静态方法。</li>
<li>必须是同样签名 (signature)，包括参数、返回类型。</li>
<li>重写方法不能缩小可见范围。</li>
</ul>


<p>重写是面向对象编程的核心概念，是<strong>唯一</strong>鼓励使用的 Name Reuse 场景。</p>

<pre><code class="java">    class Base {
        protected void f() { }
    }

    class Derived extends Base {
        public void f() { } // overrrides Base.f()
    }
</code></pre>

<h2>Overloading</h2>

<p><blockquote><p>Methods in a class overload one another if they have the same name and different signatures.</p><footer><strong>JLS 8.4.9</strong></footer></blockquote></p>

<p>重载和重写是 Name Reuse 出现最多的场景。相对于重写，重载规范包括：</p>

<ul>
<li>Context 只有一个类。</li>
<li>载体可以是实例方法，也可以是静态方法。</li>
<li>拥有不同的签名。

<ul>
<li>但不能是参数相同，返回类型不同。</li>
</ul>
</li>
</ul>


<pre><code class="java">    class CircuitBreaker {
        public void f(int i)    { }  // int overloading
        public void f(String s) { }  // String overloading
    } 
</code></pre>

<h2>Hiding</h2>

<p><blockquote><p>A field, static method, or member type hides all accessible fields, static methods, or member types, respectively, with the same name (or, for methods, signature) in supertypes. Hiding a member prevents it from being inherited.</p><footer><strong>JLS 8.3-8.5</strong></footer></blockquote></p>

<p>Hiding 和重写场景比较像，重写的载体是实例方法，而 Hiding 的载体是除去实例方法以外的其他所有元素。</p>

<ul>
<li>Context 包括子类和父类。</li>
<li>载体包括属性、静态方法、成员类。</li>
<li>同样签名。</li>
<li>可见范围无约束。</li>
</ul>


<pre><code class="java">    class Base {
        public String className = "Base";
    }

    class Derived extends Base {
        private String className = "Derived";
    }

    public class PrivateMatter {
        public static void main(String[] args) {
            System.out.println(new Derived().className);
        }
    }
</code></pre>

<p>️️️代码结果</p>

<pre><code>PrivateMatter.java:11: className has private access in Derived
           System.out.println(new Derived().className);
</code></pre>

<p>很明显，Hiding 的代码是晦涩难懂的，更重要的是它破坏了 Liskov 替换原则。应极力避免这种 Name Reuse 场景。</p>

<p><blockquote><p>Everything you can do with a base class, you can also do with a derived class.</p><footer><strong>Liskov Substitution Principle</strong></footer></blockquote></p>

<h2>Shadowing</h2>

<p><blockquote><p>A variable, method, or type shadows all variables, methods, or types, respectively, with the same name in a textually enclosing scope.</p><footer><strong>JLS 6.3.1</strong></footer></blockquote></p>

<ul>
<li>Context 可能只有一个类，也可能包括别的函数库的类。</li>
<li>载体包括变量、方法和类。</li>
</ul>


<pre><code class="java">    class WhoKnows {
        static String sentence = "I don’t know.";
        public static void main(String[] args) {
            String sentence = "I know!";   // shadows static field
            System.out.println(sentence);  // prints local variable
        }
    }
</code></pre>

<pre><code class="java">public class StrungOut {
       public static void main(String[] args) {
           String s = new String("Hello world");
           System.out.println(s);
       }
}

class String {
        private final java.lang.String s;
        public String(java.lang.String s) {
            this.s = s;
        }
        public java.lang.String toString() {
            return s;
        } 
}
</code></pre>

<p>代码结果</p>

<pre><code>Exception in thread "main" java.lang.NoSuchMethodError: main
</code></pre>

<p>产生 Shadowing 场景的 Name Reuse，依最近的作用域来判定是哪个元素有效。</p>

<h2>Obscuring</h2>

<p>Obscuring 是指在作用域中，一个变量的名字和一个类相同，直接看示例代码。</p>

<pre><code class="java">    public class Obscure {
        static String System; // Obscures type java.lang.System
        public static void main(String[] args) {
            // Next line won’t compile:  System refers to static field 
            System.out.println("hello, obscure world!");
        }
    }
</code></pre>

<p><blockquote><p>If a type or a package is obscured, you cannot refer to it by its simple name except in a context where the syntax allows only a name from its namespace.</p></blockquote></p>

<h2>常见陷阱</h2>

<h2>总结</h2>

<ol>
<li>除了 Override，尽量避免 Name Reuse。</li>
<li>遵守 Java 命名规则，可以避免 Obscuring。</li>
</ol>


<!--链接-->

]]></content>
  </entry>
  
</feed>
