<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Java | Hedley]]></title>
  <link href="http://hedleyyan.github.io/tags/java/atom.xml" rel="self"/>
  <link href="http://hedleyyan.github.io/"/>
  <updated>2015-07-13T14:45:11+08:00</updated>
  <id>http://hedleyyan.github.io/</id>
  <author>
    <name><![CDATA[dL]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[不负责瞎说说 Patterns 与 Frameworks]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/07/10/zhuang-shi-zhe-mo-shi-decorate-pattern-yu-hui-diao-ji-zhi-callback-framework/"/>
    <updated>2015-07-10T17:11:00+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/07/10/zhuang-shi-zhe-mo-shi-decorate-pattern-yu-hui-diao-ji-zhi-callback-framework</id>
    <content type="html"><![CDATA[<h1>引出</h1>

<p><a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA85&amp;dq=The+disadvantage+of+wrapper+classes&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI5L-T5PnPxgIVCQuOCh1joQq6#v=onepage&amp;q=The%20disadvantage%20of%20wrapper%20classes&amp;f=false">Effective Java, Item 16</a> 中说 <em>Wrapper classes are not suited for use in callback frameworks</em>，想不明白，一顿 Google 依旧看个似懂非懂。我想把这些凌乱的线索都整理出来，抽抽剪剪排列组合一下，也许就看的透彻点了呢。</p>

<p>关于 <em>Wrapper class</em> 的引出问题，个人认为比较<a href="http://programmers.stackexchange.com/questions/117628/why-are-wrapper-classes-not-suited-for-use-in-callback-frameworks">炫酷的解答</a>。</p>

<p><blockquote><p>Because a wrapped object doesn&rsquo;t know of its wrapper, it passes a reference to itself(this) and callbacks elude the wrapper. This is known as the SELF problem [Lieberman86]. This leads to subtle bugs, like the wrapper missing the event. Or the wrapper and wrapped object both registering for the same events - leading to duplicate processing and potential concurrency issues as well. If you don&rsquo;t know (don&rsquo;t have the source code) where callbacks are registered, it may be impossible to work around this problem.</p></blockquote></p>

<h1>Panttern? Framework?</h1>

<p>引出中的 <em>Wrapper class</em> 是 <em>Decorator pattern</em> 的引出概念，<em>callback frameworks</em> 是一种 <em>framework</em>。从翻译上看，<em>pattern</em> 译为 <strong>模式</strong>，<em>framework</em> 译为 <strong>框架</strong>。那么这个 <em>pattern</em> 与 <em>framework</em> 有毛的区别呢？</p>

<!--more-->


<p><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/patterns-intro4.pdf">Introduction to Patterns and Frameworks</a> 和 <a href="http://stackoverflow.com/questions/320142/design-patterns-vs-frameworks">Design patterns vs Frameworks</a> 对这个问题都有比较系统的分析，各位看官可以细细品看一下。一言以蔽之，<em>pattern</em> 是解决某个具体问题的方案，<em>framework</em> 是一套系统架构可重用的组件（通常包括若干个 <em>pattern</em>），他们经常共同为软件系统的可重用性、可扩展性提供支持。</p>

<p><blockquote><p>Patterns support reuse of software architecture and design: Patterns capture the static and dynamic structures and collaborations of successful solutions to problems that arise when building applications in a particular domain.<br/>Frameworks support reuse of detailed design and code: A framework is an integrated set of components that collaborate to provide a reusable architecture for a family of related applications.</p></blockquote></p>

<h1>Framework</h1>

<h2>Inversion of Control</h2>

<p>打个比方：<em>Frameworks</em> 就是挖好了一堆坑，让你往里面填萝卜，填肥料。不同的肥料怎么找对应的萝卜 <em>Frameworks</em> 来接手，这个过程就是<strong>控制反转</strong>（<a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a>）啦。</p>

<p><blockquote><p>Don&rsquo;t call us, we&rsquo;ll call you.</p><footer><strong>Hollywood principle</strong></footer></blockquote></p>

<h3>Dependency injection</h3>

<p>从代码上看，<em>IoC</em> 的实现主要包括<strong>依赖注入</strong>（<a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection</a>），以及其他的一些 <em>Patterns</em>。所以准确的来说，<em>Dependency injection</em> 是实现 <em>IoC</em> 的一种途径，但是现在很多的技术鸡汤文都把它们划上了等于号，这里了解一下概念即可，无伤大雅。</p>

<p><em>So</em>，<em>Frameworks</em> 的基础是 <em>IoC</em>，而 <em>IoC</em> 的基础又是 <em>Dependency injection</em>。不要被这个高大上的名词唬到，其实它（主要）就是 <code>set</code> 方法而已。</p>

<h2>Callback frameworks</h2>

<p>如果说 <em>IoC</em> 的精髓一句话概括为：<em>Don&rsquo;t call us, we&rsquo;ll call you.</em></p>

<p>那么<strong>回调</strong>（<a href="http://www.codeweblog.com/%E6%B5%85%E6%9E%90java-callback-%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F/">callback</a>）的一句话概括就是：<em>If you call me, i will call back.</em></p>

<p><em>callback frameworks</em> 其实并不是一种具体的 <em>framework</em>，而是代表<strong>一类</strong> <em>framework</em>。比如大多数的 <em>GUI frameworks</em>，比如 <em>SAX (Streaming XML) XML parsers</em>。</p>

<h3><a name="callback_code">Demo code</a></h3>

<pre><code class="java">public class Context implements A.Callback {

    private A a;

    public void begin() {
        System.out.println("begin ...");
    }

    public void end() {
        System.out.println("end ...");
    }

    public Context() {
        this.a = new A(this);
    }

    public void doSomething() {
        this.a.doIt();
    }

    public static void main(String args[]) {
        new Context().doSomething();
    }
}

public class A {

    private final Callback callback;

    public static interface Callback {
        public void begin();
        public void end();
    }
    public A(Callback callback) {
        this.callback = callback;
    }
    public void doIt() {
        callback.begin();
        System.out.println("do something ...");
        callback.end();
    }
}
</code></pre>

<h2>Spring</h2>

<p>如果要找一种具体的 <em>framework</em>，最典型的当然非 <em>Spring</em> 莫属。</p>

<p>网上介绍的文章一箩筐，比如这两篇，<a href="http://programmers.stackexchange.com/questions/92393/what-does-the-spring-framework-do-should-i-use-it-why-or-why-not?rq=1">戳这里</a>，<a href="http://blog.csdn.net/taijianyu/article/details/2338311/">戳这里</a>。可以简单的看一下，主要是加深对 <em>Dependency injection</em> 的理解。</p>

<h1>Pattern</h1>

<h2>Decorator pattern</h2>

<p><blockquote><p>Favor composition over inheritance. Inheritance propagates any flaws in the superclass’s API, while composition lets you design a new API that hides these flaws.</p></blockquote></p>

<p>装饰者模式是<em>继承可实例化的类</em>的替代解决方案，<a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA85&amp;dq=The+disadvantage+of+wrapper+classes&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI5L-T5PnPxgIVCQuOCh1joQq6#v=onepage&amp;q=The%20disadvantage%20of%20wrapper%20classes&amp;f=false">Effective Java, Item 16</a> 一节的主题正是 <em>Favor composition over inheritance</em>。B 继承可实例化的类 A 有很多问题，比如</p>

<ul>
<li>B 依赖于 A 的实现细节，如果 A 的后续版本中更新了实现细节，可能会破坏 B</li>
<li>A 在后续版本中可能会加入新的方法，不满足 B 的 check</li>
<li>A 的后续版本中加入了新方法 m，不巧 B 提前声明了 m</li>
<li>B 不可能实现一个满意的 <code>equals</code> 方法（<a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA40&amp;dq=While+there+is+no+satisfactory+way+to+extend+an+instantiable+class+and+add+a+value+component&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI08nF6OrVxgIVhe9yCh28bQWD#v=onepage&amp;q=While%20there%20is%20no%20satisfactory%20way%20to%20extend%20an%20instantiable%20class%20and%20add%20a%20value%20component&amp;f=false">Effective Java, Item 8</a>）</li>
</ul>


<h3>Demo code</h3>

<pre><code class="java">// Wrapper class - uses composition in place of inheritance
public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {
    private int addCount = 0;

    public InstrumentedSet(Set&lt;E&gt; s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

// Reusable forwarding class
public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {
    private final Set&lt;E&gt; s;
    public ForwardingSet(Set&lt;E&gt; s)      { this.s = s;              }
    public void clear()                 { s.clear();               }
    public boolean contains(Object o)   { return s.contains(o);    }
    public boolean isEmpty()            { return s.isEmpty();      }
    public int size()                   { return s.size();         }
    public Iterator&lt;E&gt; iterator()       { return s.iterator();     }
    public boolean add(E e)             { return s.add(e);         }
    public boolean remove(Object o)     { return s.remove(o);      }
    public boolean containsAll(Collection&lt;?&gt; c) 
                                        { return s.containsAll(c); }
    public boolean addAll(Collection&lt;? extends E&gt; c)
                                        { return s.addAll(c);      }
    public boolean removeAll(Collection&lt;?&gt; c)
                                        { return s.removeAll(c);   }
    public boolean retainAll(Collection&lt;?&gt; c)
                                        { return s.retainAll(c);   }
    public Object[] toArray()           { return s.toArray();      }
    public &lt;T&gt; T[] toArray(T[] a)       { return s.toArray(a);     }
    @Override public boolean equals(Object o)
                                        { return s.equals(o);      }
    @Override public int hashCode()     { return s.hashCode();     }
    @Override public String toString()  { return s.toString();     }
}
</code></pre>

<h1>再谈引出</h1>

<p><em>Wrapper classes are not suited for use in callback frameworks</em>，在了解了相关的各种基本概念后，现在可以给出示例代码了。结合之前介绍的 <a href="#callback_code">callback framework demo code</a> 进行说明，给 <code>Context</code> 一个 <em>Wrapper class</em>，观察效果。</p>

<pre><code class="java">public class ContextB implements Callback {

    Callback real;

    public ContextB(Callback real) {
        this.real = real;
    }

    @Override
    public void begin() {
        System.out.println("B begin ...");
        real.begin();
    }

    @Override
    public void end() {
        System.out.println("B end ...");
        real.end();
    }

    public void ex() {
        System.out.println("B ex ...");
        real.ex();
    }

    public static void main(String args[]) {
        Callback real = new Context();
        new ContextB(real).ex();
    }
}
</code></pre>

<p>观察输出，有豁然开朗的感觉吗？有请点赞~</p>

<pre><code class="java">B ex ...
begin ...
do something ...
end ...
</code></pre>

<h1>扩展阅读</h1>

<ul>
<li><a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA85&amp;dq=The+disadvantage+of+wrapper+classes&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI5L-T5PnPxgIVCQuOCh1joQq6#v=onepage&amp;q=The%20disadvantage%20of%20wrapper%20classes&amp;f=false">Effective Java, Item 16</a></li>
<li><a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA40&amp;dq=While+there+is+no+satisfactory+way+to+extend+an+instantiable+class+and+add+a+value+component&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI08nF6OrVxgIVhe9yCh28bQWD#v=onepage&amp;q=While%20there%20is%20no%20satisfactory%20way%20to%20extend%20an%20instantiable%20class%20and%20add%20a%20value%20component&amp;f=false">Effective Java, Item 8</a></li>
<li><a href="http://programmers.stackexchange.com/questions/117628/why-are-wrapper-classes-not-suited-for-use-in-callback-frameworks">Why are wrapper classes not suited for use in callback frameworks</a></li>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/patterns-intro4.pdf">Introduction to Patterns and Frameworks</a></li>
<li><a href="http://stackoverflow.com/questions/320142/design-patterns-vs-frameworks">Design patterns vs Frameworks</a></li>
<li><a href="http://www.codeweblog.com/%E6%B5%85%E6%9E%90java-callback-%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F/">浅析 Java Callback 回调模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control 维基百科</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection 维基百科</a></li>
<li><a href="http://programmers.stackexchange.com/questions/92393/what-does-the-spring-framework-do-should-i-use-it-why-or-why-not?rq=1">What is dependency injection</a></li>
<li><a href="http://blog.csdn.net/taijianyu/article/details/2338311/">什么是依赖注入</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[危机四伏整型运算]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/24/wei-ji-si-fu-zheng-xing-bian-jie/"/>
    <updated>2015-06-24T09:10:09+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/24/wei-ji-si-fu-zheng-xing-bian-jie</id>
    <content type="html"><![CDATA[<h1>关于</h1>

<p>哈？整型运算？听起来好 <em>EASY</em> 啊喂！直奔主题咯。</p>

<h1>边界陷阱</h1>

<p>无论何时，请注意整型运算的边界问题，考虑最大值，最小值，越界的可能性。</p>

<h2><em>Puzzle 3: Long Division</em></h2>

<pre><code class="java">    public class LongDivision {
        public static void main(String[] args) {
            final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
            final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
            System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);
        } 
    }
</code></pre>

<!--more-->


<p><em>EASY</em> 无压力，一目了然整型越界。 <code>MICROS_PER_DAY</code> 虽然声明为 <code>long</code>，可以装下计算结果，但是计算结果本身先是以 <code>int</code> 类型进行计算，计算完成后再赋值给 <code>MICROS_PER_DAY</code> 的。很不幸，在计算的时候就溢出了。</p>

<p>修改太简单，加一个类型声明后缀，大写的 <code>L</code>。</p>

<pre><code class="java">    public class LongDivision {
        public static void main(String[] args) {
            final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000L;
            final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000L;
            System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);
        } 
    }
</code></pre>

<h2><em>Puzzle 26: In the Loop</em></h2>

<pre><code class="java">    public class InTheLoop {
        public static final int END = Integer.MAX_VALUE;
        public static final int START = END - 100;

        public static void main(String[] args) {
            int count = 0;
            for (int i = START; i &lt;= END; i++)
                count++;
                System.out.println(count);
            }
    }
</code></pre>

<p>如果你没有仔细的看代码，可能会认为输出 <code>100</code>；如果你仔细一点，会发现这不是 <code>for</code> 循环的惯用语法 <em>(idiom)</em>，可能会认为输出 <code>101</code>。<em>Well</em> 都不是，你会发现没有输出，代码陷入了无限循环 <em>(Infinite loop)</em>。因为所有的 <code>int</code> 值都 <code>&lt;= Integer.MAX_VALUE</code>。</p>

<p>此外，将函数 <code>f(int)</code> 应用到所有的 40 亿整数的 <em>idiom</em> 是这个样子滴</p>

<pre><code class="java">// Apply the function f to all four billion int values
int i = Integer.MIN_VALUE;
do {
    f(i);
} while (i++ != Integer.MAX_VALUE);
</code></pre>

<h2><em>Puzzle 33: Infinite loop</em></h2>

<pre><code class="java">    while (i == -i &amp;&amp; i != 0) {

    }
</code></pre>

<p>给 <code>i</code> 一个声明，使上面的语句陷入 <em>Infinite loop</em>。</p>

<p>答案是 <code>int i = Integer.Integer.MIN_VALUE</code>。所以注意，相应的还有一个小陷阱， <code>Math.abs()</code> 可以 <code>&lt; 0</code>。</p>

<h2><em>Puzzle 65: A Strange Saga of a Suspicious Sort</em></h2>

<p>以下是一个将 100 个随机整数排序的代码段，短小精悍帅的很呢。但是很遗憾，输出基本都不会是众望所归的 <code>Order.DESCENDING</code>，问题出在哪呢？</p>

<pre><code class="java">import java.util.*;

public class SuspiciousSort {
    public static void main(String[] args) {
        Random rnd = new Random();
        Integer[] arr = new Integer[100];
        for (int i = 0; i &lt; arr.length; i++)
            arr[i] = rnd.nextInt();
        Comparator&lt;Integer&gt; cmp = new Comparator&lt;Integer&gt;() {
            public int compare(Integer i1, Integer i2) {
                return i2 - i1;
            }
        };
        Arrays.sort(arr, cmp);
        System.out.println(order(arr));
    }

    enum Order {
        ASCENDING, DESCENDING, CONSTANT, UNORDERED
    };

    static Order order(Integer[] a) {
        boolean ascending = false;
        boolean descending = false;
        for (int i = 1; i &lt; a.length; i++) {
            ascending |= (a[i] &gt; a[i - 1]);
            descending |= (a[i] &lt; a[i - 1]);
        }
        if (ascending &amp;&amp; !descending)
            return Order.ASCENDING;
        if (descending &amp;&amp; !ascending)
            return Order.DESCENDING;
        if (!ascending)
            return Order.CONSTANT;  // All elements equal
        return Order.UNORDERED;     // Array is not sorted
    }
}
</code></pre>

<p>问题出在 <code>Comparator&lt;Integer&gt; cmp</code> 上，虽然它的实现是喜闻乐见的 <em>idiom</em>。考虑以下的代码段</p>

<pre><code class="java">    public class Overflow {
        public static void main(String[] args) {
            int x = -2000000000;
            int z = 2000000000;
            System.out.println(x - z);
        } 
    }
</code></pre>

<p><code>x &lt; y</code>，并不一定代表 <code>x - y &lt; 0</code>。在用 <code>Comparator.compare()</code> 的 <em>idiom</em> 时候，请确认边界问题。</p>

<p>修改代码很简单，用现成的类库方法 <code>Collections.reverseOrder()</code> 提供逆序排列子。</p>

<p><blockquote><p>Do not use a subtraction-based comparator unless you are sure that the difference between values will never be greater than Integer.MAX_VALUE.</p></blockquote></p>

<h1>类型转换</h1>

<p><em><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html">JSL</a></em> 定义了若干类型转换，关于整型的有三种</p>

<ul>
<li>Widening Primitive Conversion

<ul>
<li>byte to short, int, long, float, or double</li>
<li>short to int, long, float, or double</li>
<li>char to int, long, float, or double</li>
<li>int to long, float, or double</li>
<li>long to float or double</li>
<li>float to double</li>
</ul>
</li>
<li>Narrowing Primitive Conversion

<ul>
<li>short to byte or char</li>
<li>char to byte or short</li>
<li>int to byte, short, or char</li>
<li>long to byte, short, char, or int</li>
<li>float to byte, short, char, int, or long</li>
<li>double to byte, short, char, int, long, or float</li>
</ul>
</li>
<li>Widening and Narrowing Primitive Conversion

<ul>
<li>byte to char</li>
</ul>
</li>
</ul>


<p>整型的扩宽类型转换不会丢失值信息，声明中可直接转换。所有的缩窄类型转换都有可能丢失值信息，所以必须做显示的类型转换。</p>

<p>最奇怪的是第三种，一次类型转换既有扩宽又有缩窄。因为 <code>char</code> 无符号整型特殊一点，其实 <code>byte</code> 是先转为 <code>int</code>，然后再转为了 <code>char</code>。</p>

<h2><em>Puzzle 6: Multicast</em></h2>

<pre><code class="java">    public class Multicast {
        public static void main(String[] args) {
            System.out.println((int) (char) (byte) -1);     // 65535
        }
    }
</code></pre>

<p>转换过程</p>

<ul>
<li>(int) -1 ➡️ (byte) -1 : 0xffff ➡️ 0xf   <em>(narrowing)</em></li>
<li>(byte) -1 ➡️ (char) -1      <em>(widening and narrowing)</em>

<ul>
<li>(byte) -1 ➡️ (int) - 1 : 0xf ➡️ 0xffff</li>
<li>(int) -1 ➡️ (char) 65535 : 0xffff ➡️ 0xff</li>
</ul>
</li>
<li>(char) 65535 ➡️ (int) 65535 : 0xff ➡️ 0xffff    <em>(widening)</em></li>
</ul>


<p><strong>秘籍：当心 <em>Narrowing Primitive Conversion</em> 的值变化。</strong></p>

<h1><em>Other Tips</em></h1>

<h2><em>Puzzle 1: 求余</em></h2>

<p>以下是判断一个整数是否为奇数的方法，可行吗？</p>

<pre><code class="java">    public static boolean isOdd(int i) {
       return i % 2 == 1;
    }
</code></pre>

<p><em>One Quarter</em> 的情况下不可行：当 <code>i</code> 为负奇数时， <code>i % 2 == -1</code>。</p>

<pre><code class="java">    public static boolean isOdd(int i) {
       // esay fix
       return i % 2 != 0;
       // for performance-critical
       return i &amp; 1 == 0;
    }
</code></pre>

<h2><em>Puzzle 27: 移位</em></h2>

<pre><code class="java">    public class Shifty {
        public static void main(String[] args) {
            int i = 0;
            while (-1 &lt;&lt; i != 0)
                i++;
            System.out.println(i);
        } 
    }
</code></pre>

<p>因为 -1 的二进制表示 0xffff 有 32 位 1，所以输出应该是 32 吧？但是这是一个 <em>Infinite loop</em>。因为 -1 左移 32 位还是 -1。</p>

<p><blockquote><p>Shift operators use only the five low-order bits of their right operand as the shift distance, or six bits if the left operand is a long.</p></blockquote></p>

<h2><em>Puzzle 31: 组合运算符</em></h2>

<pre><code class="java">    while (i != 0) {
        i &gt;&gt;&gt;= 1;
    }
</code></pre>

<p>给 <code>i</code> 一个声明，使上面的语句陷入 <em>Infinite loop</em>。</p>

<p><blockquote><p>Compound assignment operators is that they can silently perform narrowing primitive conversions.</p></blockquote></p>

<p>答案可以是 <code>short i = -1</code>。所有非 <code>long</code> 的整型在运算时都需要转换为 <code>int</code>，该运算的步骤拆分为</p>

<ul>
<li>(short) -1 ➡️ (int) -1 : 0xff ➡️ 0xffff</li>
<li>-1 >>> 1 ➡️ 0x7fff</li>
<li>(int) 2<sup>31</sup> - 1 ➡️ (short) -1 : 0x7fff ➡️ 0xff</li>
<li><em>Infinite loop</em></li>
</ul>


<p>秘籍：不要对 <code>byte</code>, <code>short</code>, <code>char</code> 使用组合运算符。</p>

<h1>总结</h1>

<p>注意边界，注意转型，注意 <code>byte</code> <code>char</code>，注意特殊运算。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扑朔迷离浮点运算]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/20/fu-dian-yun-suan/"/>
    <updated>2015-06-20T09:44:10+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/20/fu-dian-yun-suan</id>
    <content type="html"><![CDATA[<h1>关于</h1>

<p>此文深入剖析困扰哥已久的浮点数表示和运算。</p>

<h1>定义</h1>

<p>Java 浮点数定义采纳 <a href="http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE Standard 754</a> 标准：单精度 <code>float</code> 32 位，双精度 <code>double</code> 64 位。本文主要以 <code>float</code> 为例。</p>

<p><img src="/images/float.png"></p>

<ul>
<li>最高位符号位

<ul>
<li>0 正 1 负</li>
</ul>
</li>
<li>接 8 位指数位，并有 127 的偏移量

<ul>
<li>所以指数范围为：0 - 127 ~ (2<sup>8</sup> - 1) - 127</li>
<li>全 0 和全 1 保留用特殊表示，所以指数域的修正范围为 -126 ~ 127</li>
</ul>
</li>
<li>剩下 23 位为尾数域

<ul>
<li>IEEE 要求浮点数必须是规范的，即小数点的左侧必须为1，这样腾出了一个二进制位来保存更多的尾数，即我们用 23 位尾数域表达了 24 位的尾数</li>
<li>所以尾数域上限为 2<sup>24</sup> - 1，即 0 ~ 16777215</li>
<li>10<sup>7</sup> &lt; 16777215 &lt; 10<sup>8</sup>，所以 <code>float</code> 可以精确到小数点后 7 位（<a href="#%E7%B2%BE%E5%BA%A6">存疑</a>）</li>
</ul>
</li>
</ul>


<p><img class="right" src="/images/Snip20150622_1.png" width="300" height="350"></p>

<ul>
<li>特殊表示

<ul>
<li>指数全为 0，尾数为 0 时，表示 0</li>
<li>指数全为 1，尾数为 0 时，表示无穷大</li>
<li>指数全为 1，尾数不为 0 时，表示 <code>NaN</code></li>
</ul>
</li>
</ul>


<p>示例图中的数字表示解析：</p>

<ul>
<li>符号位 0 ，表示正数</li>
<li>指数位 <code>01111100</code> ，表示 2<sup>6</sup> + 2<sup>5</sup> + 2<sup>4</sup> + 2<sup>3</sup> + 2<sup>2</sup> - 127 = -3</li>
<li>尾数域左侧补 1 位，表示 <code>101</code></li>
<li>最后值为 1 * 2<sup>-3</sup> + 1 * 2<sup>-5</sup> = 0.15625</li>
</ul>


<!--more-->


<h2><a name="精度">精度</a></h2>

<pre><code class="java">    public static void main(String[] args) {
        float c = 1.0009765625F;
        System.out.println(Integer.toBinaryString(Float.floatToIntBits(c)));
        System.out.println(c);
        System.out.println(String.format("%.11f", c));
    }
</code></pre>

<p>输出：</p>

<pre><code>111111100000000010000000000000
1.0009766
1.00097656250
</code></pre>

<p>示例中的 <code>c</code> 精确到小数点后 10 位，可以精确的由二进制表示：1.0009765625 = 2<sup>0</sup> + 2<sup>-10</sup>。</p>

<ul>
<li>第一行输出为其二进制表示，进行验证</li>
<li><code>0 01111111 00000000010000000000000</code>

<ul>
<li>指数：2<sup>7</sup> - 1 - 127 = 0</li>
<li>尾数：1.0000000001 = 2<sup>0</sup> + 2<sup>-10</sup></li>
</ul>
</li>
</ul>


<p>以上输出的第二行表示 Java 对 <code>float</code> 处理的默认精度为 7 位，但是这不表示它的存储就丢失了精度。输出的第三行加入了指定的精度，即得到了无精度损失的浮点数。</p>

<p>所以这里得到我的<strong>个人结论</strong>： <code>float</code> 的 7 位精度是<strong>规约</strong>，而不是表示结构的限制。</p>

<h2>二进制表示方法</h2>

<p>0.1 = 1.6 / 16</p>

<p>= 1 / 16 + 0.6 / 1</p>

<p>= 1 / 16 + 1.2 / 32</p>

<p>= 1 / 16 + 1 / 32 + 0.2 / 32</p>

<p>= 1 / 16 + 1 / 32 + 1.6 / 2<sup>8</sup></p>

<p>= 1 / 2<sup>4</sup> + 1 / 2<sup>5</sup> + 1 / 2<sup>8</sup> + 0.6 / 2<sup>8</sup></p>

<p>= &hellip;</p>

<p>第 6 步又回到了第 2 步一样的分子 0.6 ，所以这是一个无限循环小数</p>

<p>0.1 = 0.00011001 00011001 00011001 00011001&hellip;</p>

<h1>场景</h1>

<h2><em>Puzzle 2</em></h2>

<pre><code class="java">    public static void main(String args[]) {
        System.out.println(2.00 - 1.10);    // 0.8999999999999999
    }
</code></pre>

<p>这个简单的算式得到的结果不是期望的 0.9 ，而是 0.8999999999999999 。因为 1.1 不能被精确的保存为 <code>double</code> 类型，而被保存为了最接近 1.1 的值，不幸的是，这个值与 2.0 做减法运算后得到的不是最接近 0.9 的 <code>double</code> 值，而是输出的这个奇葩数。</p>

<pre><code class="java">    public static void main(String args[]) {
        System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10")));    // 0.90
    }
</code></pre>

<p><strong>秘籍</strong>：需要精确表示时，用 <code>BigDecimal(String str)</code> ，永远不要用浮点数做运算。</p>

<h2><em>Puzzle 28: Looper</em></h2>

<pre><code class="java">    while (i == i + 1) {

    }
</code></pre>

<p>给 <code>i</code> 一个声明，使上面的语句进入无限循环状态。。</p>

<pre><code class="java">    double i = 1.0 / 0.0;
    // Better yet, you can take advantage of a constant that is provided for you by the standard libraries:
    double i = Double.POSITIVE_INFINITY;
    // In fact, any sufficiently large floating-point value will do; for example:
    double i = 1.0e40;
</code></pre>

<p>无穷大不用说。因为浮点数不能精确保存值，当一个数很大时，它的后继邻接数 <em>(ulp)</em> 与其差值可以大于 1 。</p>

<p><blockquote><p>The distance between adjacent floating-point values is called an ulp, which is an acronym for unit in the last place. In release 5.0, the Math.ulp method was introduced to calculate the ulp of a float or double value.</p></blockquote></p>

<p><strong>秘籍：不要用浮点数做循环索引。</strong></p>

<h2><em>Puzzle 87: Strained Relations</em></h2>

<p>数学上对于 <code>=</code> 的定义满足相等关系 <em>(equivalence relation)</em> 的三个条件</p>

<ul>
<li>自反性：x ~ x for all x.</li>
<li>对称性：if x ~ y, then y ~ x.</li>
<li>传递性：if x ~ y and y ~ z, then x ~ z.</li>
</ul>


<p>那么 <em>Java</em> 中的 <code>==</code> 呢</p>

<pre><code class="java">    public static void main(String[] args) throws Exception {
        // 自反性不满足
        System.out.println(Double.NaN == Double.NaN);   // false

        // 传递性不满足
        long x = Long.MAX_VALUE;
        double y = (double)Long.MAX_VALUE;
        long z = Long.MAX_VALUE - 1;
        System.out.print((x == y) + " ");   // Imprecise! true
        System.out.print((y == z) + " ");   // Imprecise! true
        System.out.println(x == z);         // Precise    false

        // 对称性满足
    }
</code></pre>

<h1>总结</h1>

<p>注意浮点数的精度丢失以及类型转换，相对于 <code>float</code> ，优先用 <code>double</code> 。</p>

<h1>引用</h1>

<ul>
<li><a href="http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE Standard 754</a></li>
<li><a href="http://book.douban.com/subject/1328664/">Java Puzzlers</a></li>
<li><a href="http://justjavac.iteye.com/blog/1073775">学习 Java 浮点数必看文章</a></li>
<li><a href="http://hujiantao224.iteye.com/blog/727155">Java 浮点数表示详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[荒谬痛苦的内部类]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/05/huang-miu-tong-ku-de-nei-bu-lei/"/>
    <updated>2015-06-05T11:25:38+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/05/huang-miu-tong-ku-de-nei-bu-lei</id>
    <content type="html"><![CDATA[<h1><a name="about">关于</a></h1>

<p>此文简单总结嵌套类 <em>(Nested Class)</em> 的使用场景与一般建议：能使用<strong>静态嵌套类</strong> <em>(Static Nested Class)</em> 的时候就不用<strong>内部类</strong> <em>(Inner Class)</em>。</p>

<p><blockquote><p>A nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class.</p></blockquote></p>

<!--more-->


<h1>分类定义</h1>

<h2>按位置</h2>

<ul>
<li>成员嵌套类 <em>(Member Nested Class)</em> ：作为外部类 <em>(Enclosing Class)</em> <strong>成员</strong>定义，成员嵌套类有 <em>Enclosing Class</em> 的属性。

<ul>
<li>可以使用 <code>public</code>、 <code>private</code> 等访问控制符，也可以用 <code>static</code>、 <code>final</code> 关键字</li>
</ul>
</li>
<li>局部嵌套类 <em>(Local Nested Class)</em> ：局部嵌套类定义在 <em>Enclosing Class</em> 的方法里面，局部嵌套类有 <em>Enclosing Class</em> 的属性和外部方法 <em>(Enclosing Method)</em> 的属性。

<ul>
<li>可以使用 <code>final</code> 关键字，不能使用访问控制符</li>
<li>局部类不能在外部进行创建，只能在方法调用的时候进行创建</li>
<li><em>Enclosing Method</em> 可以是静态方法，可以是实例方法，也可以是构造器方法或者静态初始化语句块</li>
<li>在 <code>static</code> 上下文定义的局部类，没有指向父类实例变量的引用</li>
</ul>
</li>
<li>匿名嵌套类 <em>(Anonymous Nested Class)</em> ：匿名嵌套类没有显示的定义一个类，直接通过 <code>new</code> 的方法创建类的实例。

<ul>
<li>不使用任何关键字和访问控制符</li>
</ul>
</li>
</ul>


<h2>按功能</h2>

<p>大多数情况下，嵌套类都按功能分为：</p>

<ul>
<li>静态嵌套类 <em>(Static Nested Class)</em> ：<code>static</code> 修饰的<strong>成员嵌套类</strong>。</li>
<li>内部类 <em>(Inner Class)</em> ：静态嵌套类之外所有的嵌套类的总称。

<ul>
<li>内部类不能定义为 <code>static</code>，不能有 <code>static</code> 方法和 <code>static</code> 初始化语句块</li>
<li>可以有 <code>static final</code> 常量属性，但不推荐这么用（放外部类就 <em>OK</em> ，为什么用在这？）</li>
</ul>
</li>
</ul>


<p>所以，局部嵌套类和匿名嵌套类肯定是内部类，成员嵌套类则分为静态嵌套类和内部类。</p>

<p><blockquote><p>An inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers or member interfaces.</p></blockquote></p>

<pre><code class="java">// 嵌套类实例代码，略
</code></pre>

<h1>痛苦场景</h1>

<h2><em>Puzzle 80</em>：反射</h2>

<pre><code class="java">public class Outer {
    public static void main(String[] args) throws Exception {
        new Outer().greetWorld();
    }

    private void greetWorld() throws Exception {
        System.out.println(Inner.class.newInstance());
    }

    public class Inner {
        public String toString() {
            return "Hello world";
        }
    }
}
</code></pre>

<p>代码看上去就是一个花样 <em>Hello world</em>，但是当你执行时，<em>Bazinga</em>！</p>

<pre><code>Exception in thread "main" java.lang.InstantiationException: test.Outer$Inner
    at java.lang.Class.newInstance0(Class.java:342)
    at java.lang.Class.newInstance(Class.java:310)
    at test.Outer.greetWorld(Outer.java:10)
    at test.Outer.main(Outer.java:6)
</code></pre>

<p><em>OK</em> ，看来 <em>inner class</em> 持有 <em>enclosing class</em> 的一个实例变量 <em>(immediately enclosing instance)</em> 是真的！编译器没那么牛逼每次都可以悄悄替你做了所有的事，至少在使用反射初始化时， <em>enclosing class</em> 的 <em>instance</em> 不会传进来。</p>

<p><blockquote><p>The constructor of a non-static nested class is compiled such that it has as its first parameter an additional implicit parameter representing the immediately enclosing instance.</p><footer><strong>JLS 13.1</strong></footer></blockquote></p>

<p><blockquote><p>This parameter is passed implicitly when you invoke the constructor from any point in the code where the compiler can find an appropriate enclosing instance. But this applies only when you invoke the constructor normally: nonreflectively.</p></blockquote></p>

<p>用含参的构造方法测试一下：</p>

<pre><code class="java">private void greetWorld() throws Exception {
       Constructor c = Inner.class.getConstructor(Outer.class);
       System.out.println(c.newInstance(Outer.this));
}
</code></pre>

<p><em>bingo</em> ！观察一下，这个场景中为什么要使用 <em>inner class</em> 呢，明明 <em>static nested class</em> 就可以嘛！ <em>so</em> 更帅的解决办法是：</p>

<pre><code class="java">public static class Inner { ... }
</code></pre>

<p><strong>秘籍：能用静态嵌套类解决，就不用内部类。</strong></p>

<h2><em>Puzzle 89</em>：泛型</h2>

<pre><code class="java">public class LinkedList&lt;E&gt; {
    private Node&lt;E&gt; head = null;

    private class Node&lt;E&gt; {
        E value;

        Node&lt;E&gt; next;

        // Node constructor links the node as a new head
        Node(E value) {
            this.value = value;
            this.next = head;
            head = this;
        }
    }

    public void add(E e) {
        new Node&lt;E&gt;(e);     // Link node as new head
    }

    public void dump() {
        for (Node&lt;E&gt; n = head; n != null; n = n.next)
            System.out.print(n.value + " ");
    }

    public static void main(String[] args) {
        LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();
        list.add("world");
        list.add("Hello");
        list.dump();
    }
}
</code></pre>

<p>代码看上去就是另一个花样 <em>Hello world</em>，但是当你执行时，<em>Double Bazinga</em> ！</p>

<pre><code>Exception in thread "main" java.lang.Error: Unresolved compilation problems: 
    Type mismatch: cannot convert from LinkedList&lt;E&gt;.Node&lt;E&gt; to LinkedList&lt;E&gt;.Node&lt;E&gt;
    Type mismatch: cannot convert from LinkedList&lt;E&gt;.Node&lt;E&gt; to LinkedList&lt;E&gt;.Node&lt;E&gt;

    at test.LinkedList$Node.&lt;init&gt;(LinkedList.java:15)
    at test.LinkedList.add(LinkedList.java:21)
    at test.LinkedList.main(LinkedList.java:32)
</code></pre>

<p><code>LinkedList&lt;E&gt;.Node&lt;E&gt;</code> 和 <code>LinkedList&lt;E&gt;.Node&lt;E&gt;</code> 类型不符？？？</p>

<p>原因是前面的 <code>Node&lt;E&gt;</code> 与后面的 <code>Node&lt;E&gt;</code> 虽然看上去一模一样，但它们压根就不是一个类型。具体点说，因为这段代码有两个 <code>&lt;E&gt;</code> 类型声明 <em>(type parameter)</em>，第一个是 <code>LinkedList</code> 的 <code>&lt;E&gt;</code> ，第二个是 <code>LinkedList.Node</code> 的 <code>&lt;E&gt;</code> 。后面的 <em><a href="http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse/#shadowing">Shadow</a></em> 了前面的。</p>

<p>如果这里把 <em>inner class</em> 的声明换一个 <em>type parameter</em> <code>Node&lt;T&gt;</code> ，可以看到更多一点的细节：</p>

<pre><code>...
    Type mismatch: cannot convert from LinkedList&lt;E&gt;.Node&lt;E&gt; to LinkedList&lt;E&gt;.Node&lt;T&gt;
    Type mismatch: cannot convert from LinkedList&lt;E&gt;.Node&lt;T&gt; to LinkedList&lt;E&gt;.Node&lt;E&gt;
...
</code></pre>

<p><blockquote><p>An inner class of a generic class has access to the type parameters of its outer class.</p></blockquote></p>

<p><em>So</em>，<em>inner class</em> 可以访问 <em>enclosing class</em> 的各种属性，包括 <em>type parameter</em> 。</p>

<p>这段代码的初衷本来就是 <code>Node</code> 持有和 <code>LinkedList</code> 一样的  <em>type parameter</em> ，所以我们可以这样修正：</p>

<pre><code class="java">public class LinkedList&lt;E&gt; {
    private Node head = null;

    private class Node {
        E value;

        Node next;

        // Node constructor links the node as a new head
        Node(E value) {
            this.value = value;
            this.next = head;
            head = this;
        }
    }

    public void add(E e) {
        new Node(e);        // Link node as new head
    }

    public void dump() {
        for (Node n = head; n != null; n = n.next)
            System.out.print(n.value + " ");
    }
}
</code></pre>

<p>但是这不是一个漂亮的修正。它的功能完全可以通过 <em>static nested class</em> 实现；并且 <em>inner class</em> 的构造方法里修改了 <em>enclosing class</em> 的属性 <code>head</code> ，<strong>这不是好的实践</strong>。</p>

<p><blockquote><p>Change instance fields of a class only in its own instance methods.</p></blockquote></p>

<p>更帅的解决方法当然是用 <em>static nested class</em> 实现 <code>Node</code> ，并且把对 <em>enclosing class</em> 的属性修改抽离出来。</p>

<pre><code class="java">class LinkedList&lt;E&gt; {
    private Node&lt;E&gt; head = null;

    private static class Node&lt;T&gt; {
        T value;

        Node&lt;T&gt; next;

        Node(T value, Node&lt;T&gt; next) {
            this.value = value;
            this.next = next;
        }
    }

    public void add(E e) {
        head = new Node&lt;E&gt;(e, head);
    }

    public void dump() {
        for (Node&lt;E&gt; n = head; n != null; n = n.next)
            System.out.print(n.value + " ");
    }
}
</code></pre>

<p>这样 <code>Node&lt;T&gt;</code> 完全与他的 <code>LinkedList&lt;E&gt;</code> 是解耦合的，想象一下你不止可以声明一个 <code>Node&lt;E&gt;</code> ，你完全可以声明 <code>Node&lt;Integer&gt;</code> 、 <code>Node&lt;String&gt;</code> ，是不是爽多了。</p>

<p><strong>秘籍1：类 A 的成员变量，只在 A 的成员方法里改。</strong> <br>
<strong>秘籍2：能用静态嵌套类解决，就不用内部类！！</strong></p>

<h2><em>Puzzle 90</em>：嵌套继承</h2>

<pre><code class="java">public class Outer {
       class Inner1 extends Outer {}
       class Inner2 extends Inner1 {}
}
</code></pre>

<p>为什么这么简单的代码就是不给编译过呢？搞咩？不过这次的错误提示好像有点帮助。。</p>

<pre><code>    No enclosing instance of type Outer is available due to some intermediate constructor invocation.
    at test.Outer$Inner2.&lt;init&gt;(Outer.java:8)
    ...
</code></pre>

<p><blockquote><p>The instantiation of an inner class, requires an enclosing instance to be supplied to the constructor. Normally, it is supplied implicitly, but it can also be supplied explicitly with a superclass constructor invocation of the form expression.super(args).</p><footer><strong>JLS 8.8.7</strong></footer></blockquote></p>

<p>原来 <em>inner class</em> 可以显示调用 <em>enclosing instance</em> ，编译器帮不了还得自己来。和<a href="#puzzle-80">反射</a>很像嘛</p>

<pre><code class="java">class Inner2 extends Inner1 {
    // Plan A
    Inner2(Outer outer) {
        outer.super();
    }
}
</code></pre>

<p>也可以</p>

<pre><code class="java">class Inner2 extends Inner1 {
    // Plan B
    Inner2() {
        Outer.this.super();
    }
}
</code></pre>

<p><em>《Thinking in Java》</em> 推荐 <em>Plan A</em> 的写法，它更通用一些。如果 <code>Inner2</code> 不是 <code>Outer</code> 的 <em>inner class</em> ，它只能用 <em>Plan A</em> 的写法来继承 <code>Inner1</code>， 无论是否 <code>Inner1 extends Outer</code> 。</p>

<pre><code class="java">public class Outer {
    class Inner1 {};
}

class Inner2 extends Outer.Inner1 {
    // Outer.this doesn't work here
    public Inner2(Outer outer) {
        outer.super();
    }
}
</code></pre>

<p><em>OK</em> ，是不是有点晕？晕就对了。无论何时，当你要写一个 <em>inner class</em> 的时候，问问自己，真的不可以用 <em>static nested class</em> 来代替吗？真的有必要吗？ <em>inner class</em> 还要继承 <em>enclosing class</em> ？真的真的有必要吗？</p>

<p><strong>秘籍1：尽量避免继承内部类。</strong> <br>
<strong>秘籍2：能用静态嵌套类解决，就不用内部类！！！！</strong></p>

<h2><em>Puzzle 92</em>：另类匿名类</h2>

<pre><code class="java">public class Twisted {
    private final String name;

    Twisted(String name) {
        this.name = name;
    }

    private String name() {
        return name;
    }

    private void reproduce() {
        new Twisted("reproduce") {
            void printName() {
                System.out.println(name());
            }
        }.printName();
    }

    public static void main(String[] args) {
        new Twisted("main").reproduce();
    }
}
</code></pre>

<p>肤浅的分析：无法编译！因为 <code>reproduce</code> 里面的 <em>anonymous class</em> 尝试访问 <code>Twisted</code> 的 <code>private</code>方法。而 <code>private</code> 的属性应该只有    <code>Twisted</code> 可以访问。 <br></p>

<p><blockquote><p>Within a top-level type, all the local, inner, nested, and anonymous classes can access one another’s members without any restrictions.</p><footer><strong>JLS 6.6.1</strong></footer></blockquote></p>

<p>其实 <em>nested class</em> 和 <em>enclosing class</em> 就是一家子， <em>enclosing class</em> 的所有成员变量都可以被 <em>nested class</em> 无限制访问。</p>

<p>知道了这个振奋人心的消息后，你的答案可能是：输出 <code>reproduce</code> 。显而易见，我使用了 <code>reproduce</code> 作为参数传入构造函数产生实例 <code>new Twisted("reproduce")</code> ，调用 <code>printName()</code> 方法，再调用 <code>name()</code> 方法，输出。但很遗憾，它的输出是 <code>main</code> 。</p>

<p><blockquote><p>Private members are never inherited.</p><footer><strong>JLS 8.2</strong></footer></blockquote></p>

<p><strong>私有方法无法被继承！</strong> <em>This is the key</em>！ <em>So</em> ，<code>new Twisted("reproduce")</code> 实例没有 <code>name()</code> 方法，而 <code>printName()</code> 方法会依最小作用域找到 <code>enclosing instance</code> 的 <code>name()</code> 方法并调用。</p>

<p><strong>秘籍：避免一个内部类继承它的外部类。</strong></p>

<h1>总结</h1>

<p>说到口都干了：能用静态嵌套类解决，就不用内部类。
<blockquote><p>Unless you have a compelling need for an enclosing instance, prefer static member classes over nonstatic.</p><footer><strong>EJ Item 18</strong></footer></blockquote></p>

<!--## 引用-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Glossary of Name Reuse]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse/"/>
    <updated>2015-05-16T17:07:57+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/05/16/a-glossary-of-name-reuse</id>
    <content type="html"><![CDATA[<h1>关于</h1>

<p>此文大概就是《Java Puzzlers》中 <em>Classier Pazzlers</em> 一节的简单翻译和整理，粗略总结了 <em>Java</em> 有关<strong>命名重复</strong>的场景和代码示例。</p>

<!--more-->


<h1>Overriding</h1>

<p><blockquote><p>An instance method overrides all accessible instance methods with the same signature in superclasses.</p><footer><strong>JLS 8.4.8.1</strong></footer></blockquote></p>

<p>重写的规范定义包括：</p>

<ul>
<li>Context 包括两个类，一个子类，一个父类。</li>
<li>载体必须是实例方法 <em>(instance methods)</em>，而非静态方法。</li>
<li>必须是同样签名 <em>(signature)</em>，包括参数、返回类型。</li>
<li>重写方法不能缩小可见范围。</li>
</ul>


<p>重写是面向对象编程的核心概念，是<strong>唯一</strong>鼓励使用的 <em>Name Reuse</em> 场景。</p>

<pre><code class="java">    class Base {
        protected void f() { }
    }

    class Derived extends Base {
        public void f() { } // overrrides Base.f()
    }
</code></pre>

<h1>Overloading</h1>

<p><blockquote><p>Methods in a class overload one another if they have the same name and different signatures.</p><footer><strong>JLS 8.4.9</strong></footer></blockquote></p>

<p>重载和重写是 <em>Name Reuse</em> 出现最多的场景。相对于重写，重载规范包括：</p>

<ul>
<li>Context 只有一个类。</li>
<li>载体可以是实例方法，也可以是静态方法。</li>
<li>拥有不同的签名。

<ul>
<li>但不能是参数相同，返回类型不同。</li>
</ul>
</li>
</ul>


<pre><code class="java">    class CircuitBreaker {
        public void f(int i)    { }  // int overloading
        public void f(String s) { }  // String overloading
    } 
</code></pre>

<h1>Hiding</h1>

<p><blockquote><p>A field, static method, or member type hides all accessible fields, static methods, or member types, respectively, with the same name (or, for methods, signature) in supertypes. Hiding a member prevents it from being inherited.</p><footer><strong>JLS 8.3-8.5</strong></footer></blockquote></p>

<p><em>Hiding</em> 和 <em>Overriding</em> 场景比较像，<em>Overriding</em> 的载体是实例方法，而 <em>Hiding</em> 的载体是除去实例方法以外的其他所有元素。</p>

<ul>
<li>Context 包括子类和父类。</li>
<li>载体包括属性、静态方法、成员类。</li>
<li>同样签名。</li>
<li>可见范围无约束。</li>
</ul>


<pre><code class="java">    class Base {
        public String className = "Base";
    }

    class Derived extends Base {
        private String className = "Derived";
    }

    public class PrivateMatter {
        public static void main(String[] args) {
            System.out.println(new Derived().className);
        }
    }
</code></pre>

<p>️️️代码结果</p>

<pre><code>PrivateMatter.java:11: className has private access in Derived
           System.out.println(new Derived().className);
</code></pre>

<p>很明显，<em>Hiding</em> 的代码是晦涩难懂的，更重要的是它破坏了 <em>Liskov</em> 替换原则。应极力避免这种 <em>Name Reuse</em> 场景。</p>

<p><blockquote><p>Everything you can do with a base class, you can also do with a derived class.</p><footer><strong>Liskov Substitution Principle</strong></footer></blockquote></p>

<h1><a name='shadowing'>Shadowing</a></h1>

<p><blockquote><p>A variable, method, or type shadows all variables, methods, or types, respectively, with the same name in a textually enclosing scope.</p><footer><strong>JLS 6.3.1</strong></footer></blockquote></p>

<ul>
<li>Context 可能只有一个类，也可能包括别的函数库的类。</li>
<li>载体包括变量、方法、类、类型声明 <em>(<T>)</em>。</li>
</ul>


<pre><code class="java">    class WhoKnows {
        static String sentence = "I don’t know.";
        public static void main(String[] args) {
            String sentence = "I know!";   // shadows static field
            System.out.println(sentence);  // prints local variable
        }
    }
</code></pre>

<pre><code class="java">    public class StrungOut {
       public static void main(String[] args) {
           String s = new String("Hello world");
           System.out.println(s);
       }
    }

    class String {
        private final java.lang.String s;
        public String(java.lang.String s) {
            this.s = s;
        }
        public java.lang.String toString() {
            return s;
        } 
    }
</code></pre>

<p>代码结果</p>

<pre><code>Exception in thread "main" java.lang.NoSuchMethodError: main
</code></pre>

<p>产生 <em>Shadowing</em> 场景的 <em>Name Reuse</em> ，依最近的作用域来判定是哪个元素有效。</p>

<h1>Obscuring</h1>

<p><em>Obscuring</em> 是指在作用域中，一个变量的名字和一个类相同，直接看示例代码。</p>

<pre><code class="java">public class Obscure {
    static String System; // Obscures type java.lang.System
    public static void main(String[] args) {
        // Next line won’t compile:  System refers to static field 
        System.out.println("hello, obscure world!");
    }
}
</code></pre>

<p><blockquote><p>If a type or a package is obscured, you cannot refer to it by its simple name except in a context where the syntax allows only a name from its namespace.</p></blockquote></p>

<h1>常见陷阱</h1>

<h1>总结</h1>

<ol>
<li>除了 <em>Override</em> ，尽量避免 <em>Name Reuse</em> 。</li>
<li>遵守 <em>Java</em> 命名规则，可以避免 <em>Obscuring</em> 。</li>
<li>避免和 <code>java.lang</code> 类库中的命名冲突。</li>
</ol>


<!--链接-->

]]></content>
  </entry>
  
</feed>
