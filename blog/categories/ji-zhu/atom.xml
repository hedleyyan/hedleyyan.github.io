<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | Hedley]]></title>
  <link href="http://hedleyyan.github.io/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://hedleyyan.github.io/"/>
  <updated>2015-07-19T23:40:26+08:00</updated>
  <id>http://hedleyyan.github.io/</id>
  <author>
    <name><![CDATA[dL]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[负责任再谈 Callback 与 Delegation]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/07/18/fu-ze-ren-zai-tan-callback-yu-delegation/"/>
    <updated>2015-07-18T15:03:11+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/07/18/fu-ze-ren-zai-tan-callback-yu-delegation</id>
    <content type="html"><![CDATA[<h1>引出</h1>

<p>话接上回<a href="/blog/2015/07/10/zhuang-shi-zhe-mo-shi-decorate-pattern-yu-hui-diao-ji-zhi-callback-framework/">不负责瞎说说 Patterns 与 Frameworks</a>，还谈引出问题：<em>Wrapper classes are not suited for use in callback frameworks</em>。虽然最后给出了一个可以验证的 <em>Demo Code</em>，但是个中缘由仍影影绰绰，真相仿佛隔着一层薄纱在向我招手。心急难耐，遂从引出 <em>SELF problem</em> 的论文出发，顺藤摸瓜按图索骥，也许是我的真心打动了上天，也许是我太帅，幸得 <a href="http://blog.csdn.net/yqj2065">yqj2065</a> 老师指点，才把真相抱了个满怀。</p>

<p>幸福来的太快，虚幻又不真实，也许我看到的只是背影，又或许我看到的是庐山真面，放空思绪，容我一点点回忆。不知道待我从求知路上走的更远，回头再看今天的“负责任”是不是够炫酷呢。</p>

<p>先甩大招上结论</p>

<ul>
<li>Java 不支持 <em>delegation</em></li>
<li>C# 的 <em>delegate</em> 不是真正的 <em>delegate</em></li>
<li><a name="想法"><em>delegation</em> ：我只需要你的原型方法，但我不要依赖于你 </a></li>
</ul>


<!--more-->


<h1>线索</h1>

<p>写完上次的“不负责任”，感觉不爽，因为 <em>SELF problem</em> 论文（<a href="https://static.aminer.org/pdf/PDF/000/522/451/using_prototypical_objects_to_implement_shared_behavior_in_object_oriented.pdf">Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems</a>）里还有理解不了的点，<em>Wrapper classes are not suited for use in callback frameworks</em> 这个问题感觉理解的还可以，但是相应的，论文里提到的 <em>delegation</em> 为什么就 OK 呢？论文里说的这个 <em>delegation</em> 又是如何实现的呢？</p>

<p>顺着论文里提到的 <em>delegation appearing several in Lisp-based object oriented systems..</em> 调查了一下 <em>Lisp</em> 语言的背景。</p>

<p>看到了 <em>Lisp</em> 的语法以后，忽感和 <em>Java8 lambda</em> 表达式长的很像。于是再查 <em>Java8 lambda</em> 是不是就是我困惑的那个 <em>delegation</em>。</p>

<p>了解了 <em>Java8 lambda</em> 的机制，并查到了较可信的<a href="http://stackoverflow.com/questions/44912/java-delegates#comment13546516_44916">证据</a>说 <em>Java8 lambda</em> 不是 <em>delegation</em>，并且以后 <em>Java</em> 都不会支持 <em>delegation</em>。</p>

<p>但是上面的信息中提到 C# 是实现了 <em>delegate</em> 的。然后了解了 C# 的 <em>delegate</em>、<em>event</em> 关键字，写了些代码来验证我的<a href="#%E6%83%B3%E6%B3%95">想法</a>。</p>

<p>但是很不幸，没有验证成功。我发现 C# 的 <em>delegate</em> 其实和 <em>Java8 lambda</em> 是一样的原理，不过是一种更方便的语法加上更灵活的实现12。</p>

<p>所以又回头开始理 <em>SELF problem</em> 论文，到底是哪里不一致。开始怀疑 C# 的 <em>delegate</em> 和论文里说的 <em>delegation</em> 不是一个频道。</p>

<p>太帅了，又找到了证据。</p>

<p>但是更帅的是，我搞懂了 <em>Callback</em>。</p>

<h1>真· <em>Callback</em></h1>

<p>上回给 <em>callback</em> 下的一句话定义：<em>If you call me, i will call back.</em>  Well，丢掉忘掉扔到垃圾桶。灵感来自<a href="http://blog.csdn.net/yqj2065/article/details/39481255">这里</a>，诚如我下面的留言：拨云见日醍醐灌顶，痛快！</p>

<p>首先， <em>callback</em> 是名词，不是动词，不是场景，它就是一个方法，是回调函数的简称。</p>

<p>其次， <em>callback</em> 是强调一个上下文的，有一个分层的概念在。</p>

<p>了解了这两点之后，理解起来简直是爽，一张类图搞定。</p>

<p><img class="right" src="/images/Snip20150719_6.png" width="400" height="300"></p>

<p><blockquote><p>一个回调函数 / 方法（简称回调 / callback）是上层模块实现的，将被下层模块（反过来）执行的方法。</p></blockquote></p>

<p>可见所谓 <em>framework</em>，根本就是建立在 <em>callback</em> 的基础上的。我们要想做填空题，那么 <em>framework</em> 封装的细节是如何调用我们的代码的呢？ <em>callback</em>！</p>

<h1><em>Delegation</em></h1>

<h2>伪· <em>Delegation</em></h2>

<h3>C# <em>delegate</em></h3>

<h3>Java8 lambda 表达式</h3>

<p><blockquote><p>It is unlikely that the Java programming language will ever include this construct. Sun already carefully considered adopting it in 1996, to the extent of building and discarding working prototypes. Our conclusion was that bound method references are unnecessary and detrimental to the language. This decision was made in consultation with Borland International, who had previous experience with bound method references in Delphi Object Pascal.</p></p><p><p>We believe bound method references are unnecessary because another design alternative, inner classes, provides equal or superior functionality. In particular, inner classes fully support the requirements of user-interface event handling, and have been used to implement a user-interface API at least as comprehensive as the Windows Foundation Classes.</p></p><p><p>We believe bound method references are harmful because they detract from the simplicity of the Java programming language and the pervasively object-oriented character of the APIs. Bound method references also introduce irregularity into the language syntax and scoping rules. Finally, they dilute the investment in VM technologies because VMs are required to handle additional and disparate types of references and method linkage efficiently.</p></blockquote></p>

<h2>真· <em>Delegation</em></h2>

<h1>乱入 <em>delegate</em> 的 <em>Patterns</em></h1>

<h1>SELF problem</h1>

<h1>扩展阅读</h1>

<ul>
<li><a href="https://static.aminer.org/pdf/PDF/000/522/451/using_prototypical_objects_to_implement_shared_behavior_in_object_oriented.pdf">Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems</a></li>
<li><a href="http://stackoverflow.com/questions/44912/java-delegates#comment13546516_44916">Java Delegates?</a></li>
<li><a href="http://stackoverflow.com/questions/20311779/is-there-delegate-in-java-8-jdk8/30925223#30925223">Is there delegate in Java 8 (JDK8)?</a></li>
<li><a href="http://stackoverflow.com/questions/1746332/delegates-and-callbacks">C# does not implement delegates</a></li>
<li><a href="http://www.saturnflyer.com/blog/jim/2012/07/06/the-gang-of-four-is-wrong-and-you-dont-understand-delegation/">The Gang Of Four Is Wrong And You Don&rsquo;t Understand Delegation</a></li>
<li><a href="http://blog.csdn.net/yqj2065/article/details/39481255">《编程导论（Java）·9.3.1Java回调》1</a></li>
<li><a href="http://blog.csdn.net/yqj2065/article/details/31441221">《编程导论（Java）·9.3.1Java回调》2</a></li>
<li><a href="http://www.onjava.com/pub/a/onjava/2003/05/21/delegates.html">A Java Programmer Looks at C# Delegates</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不负责瞎说说 Patterns 与 Frameworks]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/07/10/zhuang-shi-zhe-mo-shi-decorate-pattern-yu-hui-diao-ji-zhi-callback-framework/"/>
    <updated>2015-07-10T17:11:00+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/07/10/zhuang-shi-zhe-mo-shi-decorate-pattern-yu-hui-diao-ji-zhi-callback-framework</id>
    <content type="html"><![CDATA[<h1>引出</h1>

<p><a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA85&amp;dq=The+disadvantage+of+wrapper+classes&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI5L-T5PnPxgIVCQuOCh1joQq6#v=onepage&amp;q=The%20disadvantage%20of%20wrapper%20classes&amp;f=false">Effective Java, Item 16</a> 中说 <em>Wrapper classes are not suited for use in callback frameworks</em>，想不明白，一顿 Google 依旧看个似懂非懂。我想把这些凌乱的线索都整理出来，抽抽剪剪排列组合一下，也许就看的透彻点了呢。</p>

<p>关于 <em>Wrapper class</em> 的引出问题，个人认为比较<a href="http://programmers.stackexchange.com/questions/117628/why-are-wrapper-classes-not-suited-for-use-in-callback-frameworks">炫酷的解答</a>。</p>

<p><blockquote><p>Because a wrapped object doesn&rsquo;t know of its wrapper, it passes a reference to itself(this) and callbacks elude the wrapper. This is known as the SELF problem <a href="https://static.aminer.org/pdf/PDF/000/522/451/using_prototypical_objects_to_implement_shared_behavior_in_object_oriented.pdf">Lieberman86</a>. This leads to subtle bugs, like the wrapper missing the event. Or the wrapper and wrapped object both registering for the same events - leading to duplicate processing and potential concurrency issues as well. If you don&rsquo;t know (don&rsquo;t have the source code) where callbacks are registered, it may be impossible to work around this problem.</p></blockquote></p>

<h1>Panttern? Framework?</h1>

<p>引出中的 <em>Wrapper class</em> 是 <em>Decorator pattern</em> 的引出概念，<em>callback frameworks</em> 是一种 <em>framework</em>。从翻译上看，<em>pattern</em> 译为 <strong>模式</strong>，<em>framework</em> 译为 <strong>框架</strong>。那么这个 <em>pattern</em> 与 <em>framework</em> 有毛的区别呢？</p>

<!--more-->


<p><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/patterns-intro4.pdf">Introduction to Patterns and Frameworks</a> 和 <a href="http://stackoverflow.com/questions/320142/design-patterns-vs-frameworks">Design patterns vs Frameworks</a> 对这个问题都有比较系统的分析，各位看官可以细细品看一下。一言以蔽之，<em>pattern</em> 是解决某个具体问题的方案，<em>framework</em> 是一套系统架构可重用的组件（通常包括若干个 <em>pattern</em>），他们经常共同为软件系统的可重用性、可扩展性提供支持。</p>

<p><blockquote><p>Patterns support reuse of software architecture and design: Patterns capture the static and dynamic structures and collaborations of successful solutions to problems that arise when building applications in a particular domain.<br/>Frameworks support reuse of detailed design and code: A framework is an integrated set of components that collaborate to provide a reusable architecture for a family of related applications.</p></blockquote></p>

<h1>Framework</h1>

<h2>Inversion of Control</h2>

<p>打个比方：<em>Frameworks</em> 就是挖好了一堆坑，让你往里面填萝卜，填肥料。不同的肥料怎么找对应的萝卜 <em>Frameworks</em> 来接手，这个过程就是<strong>控制反转</strong>（<a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a>）啦。</p>

<p><blockquote><p>Don&rsquo;t call us, we&rsquo;ll call you.</p><footer><strong>Hollywood principle</strong></footer></blockquote></p>

<h3>Dependency injection</h3>

<p>从代码上看，<em>IoC</em> 的实现主要包括<strong>依赖注入</strong>（<a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection</a>），以及其他的一些 <em>Patterns</em>。所以准确的来说，<em>Dependency injection</em> 是实现 <em>IoC</em> 的一种途径，但是现在很多的技术鸡汤文都把它们划上了等于号，这里了解一下概念即可，无伤大雅。</p>

<p><em>So</em>，<em>Frameworks</em> 的基础是 <em>IoC</em>，而 <em>IoC</em> 的基础又是 <em>Dependency injection</em>。不要被这个高大上的名词唬到，其实它（主要）就是 <code>set</code> 方法而已。</p>

<h2>Callback frameworks</h2>

<p>如果说 <em>IoC</em> 的精髓一句话概括为：<em>Don&rsquo;t call us, we&rsquo;ll call you.</em></p>

<p>那么<strong>回调</strong>（<a href="http://www.codeweblog.com/%E6%B5%85%E6%9E%90java-callback-%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F/">callback</a>）的一句话概括就是：<em>If you call me, i will call back.</em></p>

<p><em>callback frameworks</em> 其实并不是一种具体的 <em>framework</em>，而是代表<strong>一类</strong> <em>framework</em>。比如大多数的 <em>GUI frameworks</em>，比如 <em>SAX (Streaming XML) XML parsers</em>。</p>

<h3><a name="callback_code">Demo code</a></h3>

<pre><code class="java">public class Context implements A.Callback {

    private A a;

    public void begin() {
        System.out.println("begin ...");
    }

    public void end() {
        System.out.println("end ...");
    }

    public Context() {
        this.a = new A(this);
    }

    public void doSomething() {
        this.a.doIt();
    }

    public static void main(String args[]) {
        new Context().doSomething();
    }
}

public class A {

    private final Callback callback;

    public static interface Callback {
        public void begin();
        public void end();
    }
    public A(Callback callback) {
        this.callback = callback;
    }
    public void doIt() {
        callback.begin();
        System.out.println("do something ...");
        callback.end();
    }
}
</code></pre>

<h2>Spring</h2>

<p>如果要找一种具体的 <em>framework</em>，最典型的当然非 <em>Spring</em> 莫属。</p>

<p>网上介绍的文章一箩筐，比如这两篇，<a href="http://programmers.stackexchange.com/questions/92393/what-does-the-spring-framework-do-should-i-use-it-why-or-why-not?rq=1">戳这里</a>，<a href="http://blog.csdn.net/taijianyu/article/details/2338311/">戳这里</a>。可以简单的看一下，主要是加深对 <em>Dependency injection</em> 的理解。</p>

<h1>Pattern</h1>

<h2>Decorator pattern</h2>

<p><blockquote><p>Favor composition over inheritance. Inheritance propagates any flaws in the superclass’s API, while composition lets you design a new API that hides these flaws.</p></blockquote></p>

<p>装饰者模式是<em>继承可实例化的类</em>的替代解决方案，<a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA85&amp;dq=The+disadvantage+of+wrapper+classes&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI5L-T5PnPxgIVCQuOCh1joQq6#v=onepage&amp;q=The%20disadvantage%20of%20wrapper%20classes&amp;f=false">Effective Java, Item 16</a> 一节的主题正是 <em>Favor composition over inheritance</em>。B 继承可实例化的类 A 有很多问题，比如</p>

<ul>
<li>B 依赖于 A 的实现细节，如果 A 的后续版本中更新了实现细节，可能会破坏 B</li>
<li>A 在后续版本中可能会加入新的方法，不满足 B 的 check</li>
<li>A 的后续版本中加入了新方法 m，不巧 B 提前声明了 m</li>
<li>B 不可能实现一个满意的 <code>equals</code> 方法（<a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA40&amp;dq=While+there+is+no+satisfactory+way+to+extend+an+instantiable+class+and+add+a+value+component&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI08nF6OrVxgIVhe9yCh28bQWD#v=onepage&amp;q=While%20there%20is%20no%20satisfactory%20way%20to%20extend%20an%20instantiable%20class%20and%20add%20a%20value%20component&amp;f=false">Effective Java, Item 8</a>）</li>
</ul>


<h3>Demo code</h3>

<pre><code class="java">// Wrapper class - uses composition in place of inheritance
public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {
    private int addCount = 0;

    public InstrumentedSet(Set&lt;E&gt; s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}

// Reusable forwarding class
public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {
    private final Set&lt;E&gt; s;
    public ForwardingSet(Set&lt;E&gt; s)      { this.s = s;              }
    public void clear()                 { s.clear();               }
    public boolean contains(Object o)   { return s.contains(o);    }
    public boolean isEmpty()            { return s.isEmpty();      }
    public int size()                   { return s.size();         }
    public Iterator&lt;E&gt; iterator()       { return s.iterator();     }
    public boolean add(E e)             { return s.add(e);         }
    public boolean remove(Object o)     { return s.remove(o);      }
    public boolean containsAll(Collection&lt;?&gt; c) 
                                        { return s.containsAll(c); }
    public boolean addAll(Collection&lt;? extends E&gt; c)
                                        { return s.addAll(c);      }
    public boolean removeAll(Collection&lt;?&gt; c)
                                        { return s.removeAll(c);   }
    public boolean retainAll(Collection&lt;?&gt; c)
                                        { return s.retainAll(c);   }
    public Object[] toArray()           { return s.toArray();      }
    public &lt;T&gt; T[] toArray(T[] a)       { return s.toArray(a);     }
    @Override public boolean equals(Object o)
                                        { return s.equals(o);      }
    @Override public int hashCode()     { return s.hashCode();     }
    @Override public String toString()  { return s.toString();     }
}
</code></pre>

<h1>再谈引出</h1>

<p><em>Wrapper classes are not suited for use in callback frameworks</em>，在了解了相关的各种基本概念后，现在可以给出示例代码了。结合之前介绍的 <a href="#callback_code">callback framework demo code</a> 进行说明，给 <code>Context</code> 一个 <em>Wrapper class</em>，观察效果。</p>

<pre><code class="java">public class ContextB implements Callback {

    Callback real;

    public ContextB(Callback real) {
        this.real = real;
    }

    @Override
    public void begin() {
        System.out.println("B begin ...");
        real.begin();
    }

    @Override
    public void end() {
        System.out.println("B end ...");
        real.end();
    }

    public void ex() {
        System.out.println("B ex ...");
        real.ex();
    }

    public static void main(String args[]) {
        Callback real = new Context();
        new ContextB(real).ex();
    }
}
</code></pre>

<p>观察输出，有豁然开朗的感觉吗？有请点赞~</p>

<pre><code class="java">B ex ...
begin ...
do something ...
end ...
</code></pre>

<h1>扩展阅读</h1>

<ul>
<li><a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA85&amp;dq=The+disadvantage+of+wrapper+classes&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI5L-T5PnPxgIVCQuOCh1joQq6#v=onepage&amp;q=The%20disadvantage%20of%20wrapper%20classes&amp;f=false">Effective Java, Item 16</a></li>
<li><a href="https://books.google.com.hk/books?id=ka2VUBqHiWkC&amp;pg=PA40&amp;dq=While+there+is+no+satisfactory+way+to+extend+an+instantiable+class+and+add+a+value+component&amp;hl=en&amp;sa=X&amp;ved=0CB0Q6AEwAGoVChMI08nF6OrVxgIVhe9yCh28bQWD#v=onepage&amp;q=While%20there%20is%20no%20satisfactory%20way%20to%20extend%20an%20instantiable%20class%20and%20add%20a%20value%20component&amp;f=false">Effective Java, Item 8</a></li>
<li><a href="http://programmers.stackexchange.com/questions/117628/why-are-wrapper-classes-not-suited-for-use-in-callback-frameworks">Why are wrapper classes not suited for use in callback frameworks</a></li>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/patterns-intro4.pdf">Introduction to Patterns and Frameworks</a></li>
<li><a href="http://stackoverflow.com/questions/320142/design-patterns-vs-frameworks">Design patterns vs Frameworks</a></li>
<li><a href="http://www.codeweblog.com/%E6%B5%85%E6%9E%90java-callback-%E5%9B%9E%E8%B0%83%E6%A8%A1%E5%BC%8F/">浅析 Java Callback 回调模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control 维基百科</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dependency_injection">Dependency injection 维基百科</a></li>
<li><a href="http://programmers.stackexchange.com/questions/92393/what-does-the-spring-framework-do-should-i-use-it-why-or-why-not?rq=1">What is dependency injection</a></li>
<li><a href="http://blog.csdn.net/taijianyu/article/details/2338311/">什么是依赖注入</a></li>
<li><a href="https://static.aminer.org/pdf/PDF/000/522/451/using_prototypical_objects_to_implement_shared_behavior_in_object_oriented.pdf">Using Prototypical Objects to Implement Shared Behavior in Object Oriented Systems</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 光标焦点集中到 FOLDERS 状态栏]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/29/sublime-text-guang-biao-jiao-dian-ji-zhong-dao-folders-zhuang-tai-lan/"/>
    <updated>2015-06-29T14:03:36+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/29/sublime-text-guang-biao-jiao-dian-ji-zhong-dao-folders-zhuang-tai-lan</id>
    <content type="html"><![CDATA[<p>搜索了若干资料，如何让光标焦点从 Editor 移动到 FOLDERS 状态栏。偶然复现过一次，却百思不得其解。</p>

<p>经过不懈尝试，终得破解大法！这下一口气看 LOG 不要太爽！</p>

<ul>
<li>点击 FOLDERS 中任意一个文件</li>
<li>再次左键点击这个文件，不要松开，紧接着点击右键</li>
<li>Bingo！</li>
</ul>


<p><strong>秘籍</strong>：左 C + [ 左 C + hold 2ms + 右 C ]，很有我当年三国战记配无限风书的神韵啊！</p>

<p><img src="/images/fengshu.jpg"></p>

<!--more-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[危机四伏整型运算]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/24/wei-ji-si-fu-zheng-xing-bian-jie/"/>
    <updated>2015-06-24T09:10:09+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/24/wei-ji-si-fu-zheng-xing-bian-jie</id>
    <content type="html"><![CDATA[<h1>关于</h1>

<p>哈？整型运算？听起来好 <em>EASY</em> 啊喂！直奔主题咯。</p>

<h1>边界陷阱</h1>

<p>无论何时，请注意整型运算的边界问题，考虑最大值，最小值，越界的可能性。</p>

<h2><em>Puzzle 3: Long Division</em></h2>

<pre><code class="java">    public class LongDivision {
        public static void main(String[] args) {
            final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
            final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
            System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);
        } 
    }
</code></pre>

<!--more-->


<p><em>EASY</em> 无压力，一目了然整型越界。 <code>MICROS_PER_DAY</code> 虽然声明为 <code>long</code>，可以装下计算结果，但是计算结果本身先是以 <code>int</code> 类型进行计算，计算完成后再赋值给 <code>MICROS_PER_DAY</code> 的。很不幸，在计算的时候就溢出了。</p>

<p>修改太简单，加一个类型声明后缀，大写的 <code>L</code>。</p>

<pre><code class="java">    public class LongDivision {
        public static void main(String[] args) {
            final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000L;
            final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000L;
            System.out.println(MICROS_PER_DAY / MILLIS_PER_DAY);
        } 
    }
</code></pre>

<h2><em>Puzzle 26: In the Loop</em></h2>

<pre><code class="java">    public class InTheLoop {
        public static final int END = Integer.MAX_VALUE;
        public static final int START = END - 100;

        public static void main(String[] args) {
            int count = 0;
            for (int i = START; i &lt;= END; i++)
                count++;
                System.out.println(count);
            }
    }
</code></pre>

<p>如果你没有仔细的看代码，可能会认为输出 <code>100</code>；如果你仔细一点，会发现这不是 <code>for</code> 循环的惯用语法 <em>(idiom)</em>，可能会认为输出 <code>101</code>。<em>Well</em> 都不是，你会发现没有输出，代码陷入了无限循环 <em>(Infinite loop)</em>。因为所有的 <code>int</code> 值都 <code>&lt;= Integer.MAX_VALUE</code>。</p>

<p>此外，将函数 <code>f(int)</code> 应用到所有的 40 亿整数的 <em>idiom</em> 是这个样子滴</p>

<pre><code class="java">// Apply the function f to all four billion int values
int i = Integer.MIN_VALUE;
do {
    f(i);
} while (i++ != Integer.MAX_VALUE);
</code></pre>

<h2><em>Puzzle 33: Infinite loop</em></h2>

<pre><code class="java">    while (i == -i &amp;&amp; i != 0) {

    }
</code></pre>

<p>给 <code>i</code> 一个声明，使上面的语句陷入 <em>Infinite loop</em>。</p>

<p>答案是 <code>int i = Integer.Integer.MIN_VALUE</code>。所以注意，相应的还有一个小陷阱， <code>Math.abs()</code> 可以 <code>&lt; 0</code>。</p>

<h2><em>Puzzle 65: A Strange Saga of a Suspicious Sort</em></h2>

<p>以下是一个将 100 个随机整数排序的代码段，短小精悍帅的很呢。但是很遗憾，输出基本都不会是众望所归的 <code>Order.DESCENDING</code>，问题出在哪呢？</p>

<pre><code class="java">import java.util.*;

public class SuspiciousSort {
    public static void main(String[] args) {
        Random rnd = new Random();
        Integer[] arr = new Integer[100];
        for (int i = 0; i &lt; arr.length; i++)
            arr[i] = rnd.nextInt();
        Comparator&lt;Integer&gt; cmp = new Comparator&lt;Integer&gt;() {
            public int compare(Integer i1, Integer i2) {
                return i2 - i1;
            }
        };
        Arrays.sort(arr, cmp);
        System.out.println(order(arr));
    }

    enum Order {
        ASCENDING, DESCENDING, CONSTANT, UNORDERED
    };

    static Order order(Integer[] a) {
        boolean ascending = false;
        boolean descending = false;
        for (int i = 1; i &lt; a.length; i++) {
            ascending |= (a[i] &gt; a[i - 1]);
            descending |= (a[i] &lt; a[i - 1]);
        }
        if (ascending &amp;&amp; !descending)
            return Order.ASCENDING;
        if (descending &amp;&amp; !ascending)
            return Order.DESCENDING;
        if (!ascending)
            return Order.CONSTANT;  // All elements equal
        return Order.UNORDERED;     // Array is not sorted
    }
}
</code></pre>

<p>问题出在 <code>Comparator&lt;Integer&gt; cmp</code> 上，虽然它的实现是喜闻乐见的 <em>idiom</em>。考虑以下的代码段</p>

<pre><code class="java">    public class Overflow {
        public static void main(String[] args) {
            int x = -2000000000;
            int z = 2000000000;
            System.out.println(x - z);
        } 
    }
</code></pre>

<p><code>x &lt; y</code>，并不一定代表 <code>x - y &lt; 0</code>。在用 <code>Comparator.compare()</code> 的 <em>idiom</em> 时候，请确认边界问题。</p>

<p>修改代码很简单，用现成的类库方法 <code>Collections.reverseOrder()</code> 提供逆序排列子。</p>

<p><blockquote><p>Do not use a subtraction-based comparator unless you are sure that the difference between values will never be greater than Integer.MAX_VALUE.</p></blockquote></p>

<h1>类型转换</h1>

<p><em><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html">JSL</a></em> 定义了若干类型转换，关于整型的有三种</p>

<ul>
<li>Widening Primitive Conversion

<ul>
<li>byte to short, int, long, float, or double</li>
<li>short to int, long, float, or double</li>
<li>char to int, long, float, or double</li>
<li>int to long, float, or double</li>
<li>long to float or double</li>
<li>float to double</li>
</ul>
</li>
<li>Narrowing Primitive Conversion

<ul>
<li>short to byte or char</li>
<li>char to byte or short</li>
<li>int to byte, short, or char</li>
<li>long to byte, short, char, or int</li>
<li>float to byte, short, char, int, or long</li>
<li>double to byte, short, char, int, long, or float</li>
</ul>
</li>
<li>Widening and Narrowing Primitive Conversion

<ul>
<li>byte to char</li>
</ul>
</li>
</ul>


<p>整型的扩宽类型转换不会丢失值信息，声明中可直接转换。所有的缩窄类型转换都有可能丢失值信息，所以必须做显示的类型转换。</p>

<p>最奇怪的是第三种，一次类型转换既有扩宽又有缩窄。因为 <code>char</code> 无符号整型特殊一点，其实 <code>byte</code> 是先转为 <code>int</code>，然后再转为了 <code>char</code>。</p>

<h2><em>Puzzle 6: Multicast</em></h2>

<pre><code class="java">    public class Multicast {
        public static void main(String[] args) {
            System.out.println((int) (char) (byte) -1);     // 65535
        }
    }
</code></pre>

<p>转换过程</p>

<ul>
<li>(int) -1 ➡️ (byte) -1 : 0xffff ➡️ 0xf   <em>(narrowing)</em></li>
<li>(byte) -1 ➡️ (char) -1      <em>(widening and narrowing)</em>

<ul>
<li>(byte) -1 ➡️ (int) - 1 : 0xf ➡️ 0xffff</li>
<li>(int) -1 ➡️ (char) 65535 : 0xffff ➡️ 0xff</li>
</ul>
</li>
<li>(char) 65535 ➡️ (int) 65535 : 0xff ➡️ 0xffff    <em>(widening)</em></li>
</ul>


<p><strong>秘籍：当心 <em>Narrowing Primitive Conversion</em> 的值变化。</strong></p>

<h1><em>Other Tips</em></h1>

<h2><em>Puzzle 1: 求余</em></h2>

<p>以下是判断一个整数是否为奇数的方法，可行吗？</p>

<pre><code class="java">    public static boolean isOdd(int i) {
       return i % 2 == 1;
    }
</code></pre>

<p><em>One Quarter</em> 的情况下不可行：当 <code>i</code> 为负奇数时， <code>i % 2 == -1</code>。</p>

<pre><code class="java">    public static boolean isOdd(int i) {
       // esay fix
       return i % 2 != 0;
       // for performance-critical
       return i &amp; 1 == 0;
    }
</code></pre>

<h2><em>Puzzle 27: 移位</em></h2>

<pre><code class="java">    public class Shifty {
        public static void main(String[] args) {
            int i = 0;
            while (-1 &lt;&lt; i != 0)
                i++;
            System.out.println(i);
        } 
    }
</code></pre>

<p>因为 -1 的二进制表示 0xffff 有 32 位 1，所以输出应该是 32 吧？但是这是一个 <em>Infinite loop</em>。因为 -1 左移 32 位还是 -1。</p>

<p><blockquote><p>Shift operators use only the five low-order bits of their right operand as the shift distance, or six bits if the left operand is a long.</p></blockquote></p>

<h2><em>Puzzle 31: 组合运算符</em></h2>

<pre><code class="java">    while (i != 0) {
        i &gt;&gt;&gt;= 1;
    }
</code></pre>

<p>给 <code>i</code> 一个声明，使上面的语句陷入 <em>Infinite loop</em>。</p>

<p><blockquote><p>Compound assignment operators is that they can silently perform narrowing primitive conversions.</p></blockquote></p>

<p>答案可以是 <code>short i = -1</code>。所有非 <code>long</code> 的整型在运算时都需要转换为 <code>int</code>，该运算的步骤拆分为</p>

<ul>
<li>(short) -1 ➡️ (int) -1 : 0xff ➡️ 0xffff</li>
<li>-1 >>> 1 ➡️ 0x7fff</li>
<li>(int) 2<sup>31</sup> - 1 ➡️ (short) -1 : 0x7fff ➡️ 0xff</li>
<li><em>Infinite loop</em></li>
</ul>


<p>秘籍：不要对 <code>byte</code>, <code>short</code>, <code>char</code> 使用组合运算符。</p>

<h1>总结</h1>

<p>注意边界，注意转型，注意 <code>byte</code> <code>char</code>，注意特殊运算。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[扑朔迷离浮点运算]]></title>
    <link href="http://hedleyyan.github.io/blog/2015/06/20/fu-dian-yun-suan/"/>
    <updated>2015-06-20T09:44:10+08:00</updated>
    <id>http://hedleyyan.github.io/blog/2015/06/20/fu-dian-yun-suan</id>
    <content type="html"><![CDATA[<h1>关于</h1>

<p>此文深入剖析困扰哥已久的浮点数表示和运算。</p>

<h1>定义</h1>

<p>Java 浮点数定义采纳 <a href="http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE Standard 754</a> 标准：单精度 <code>float</code> 32 位，双精度 <code>double</code> 64 位。本文主要以 <code>float</code> 为例。</p>

<p><img src="/images/float.png"></p>

<ul>
<li>最高位符号位

<ul>
<li>0 正 1 负</li>
</ul>
</li>
<li>接 8 位指数位，并有 127 的偏移量

<ul>
<li>所以指数范围为：0 - 127 ~ (2<sup>8</sup> - 1) - 127</li>
<li>全 0 和全 1 保留用特殊表示，所以指数域的修正范围为 -126 ~ 127</li>
</ul>
</li>
<li>剩下 23 位为尾数域

<ul>
<li>IEEE 要求浮点数必须是规范的，即小数点的左侧必须为1，这样腾出了一个二进制位来保存更多的尾数，即我们用 23 位尾数域表达了 24 位的尾数</li>
<li>所以尾数域上限为 2<sup>24</sup> - 1，即 0 ~ 16777215</li>
<li>10<sup>7</sup> &lt; 16777215 &lt; 10<sup>8</sup>，所以 <code>float</code> 可以精确到小数点后 7 位（<a href="#%E7%B2%BE%E5%BA%A6">存疑</a>）</li>
</ul>
</li>
</ul>


<p><img class="right" src="/images/Snip20150622_1.png" width="300" height="350"></p>

<ul>
<li>特殊表示

<ul>
<li>指数全为 0，尾数为 0 时，表示 0</li>
<li>指数全为 1，尾数为 0 时，表示无穷大</li>
<li>指数全为 1，尾数不为 0 时，表示 <code>NaN</code></li>
</ul>
</li>
</ul>


<p>示例图中的数字表示解析：</p>

<ul>
<li>符号位 0 ，表示正数</li>
<li>指数位 <code>01111100</code> ，表示 2<sup>6</sup> + 2<sup>5</sup> + 2<sup>4</sup> + 2<sup>3</sup> + 2<sup>2</sup> - 127 = -3</li>
<li>尾数域左侧补 1 位，表示 <code>101</code></li>
<li>最后值为 1 * 2<sup>-3</sup> + 1 * 2<sup>-5</sup> = 0.15625</li>
</ul>


<!--more-->


<h2><a name="精度">精度</a></h2>

<pre><code class="java">    public static void main(String[] args) {
        float c = 1.0009765625F;
        System.out.println(Integer.toBinaryString(Float.floatToIntBits(c)));
        System.out.println(c);
        System.out.println(String.format("%.11f", c));
    }
</code></pre>

<p>输出：</p>

<pre><code>111111100000000010000000000000
1.0009766
1.00097656250
</code></pre>

<p>示例中的 <code>c</code> 精确到小数点后 10 位，可以精确的由二进制表示：1.0009765625 = 2<sup>0</sup> + 2<sup>-10</sup>。</p>

<ul>
<li>第一行输出为其二进制表示，进行验证</li>
<li><code>0 01111111 00000000010000000000000</code>

<ul>
<li>指数：2<sup>7</sup> - 1 - 127 = 0</li>
<li>尾数：1.0000000001 = 2<sup>0</sup> + 2<sup>-10</sup></li>
</ul>
</li>
</ul>


<p>以上输出的第二行表示 Java 对 <code>float</code> 处理的默认精度为 7 位，但是这不表示它的存储就丢失了精度。输出的第三行加入了指定的精度，即得到了无精度损失的浮点数。</p>

<p>所以这里得到我的<strong>个人结论</strong>： <code>float</code> 的 7 位精度是<strong>规约</strong>，而不是表示结构的限制。</p>

<h2>二进制表示方法</h2>

<p>0.1 = 1.6 / 16</p>

<p>= 1 / 16 + 0.6 / 1</p>

<p>= 1 / 16 + 1.2 / 32</p>

<p>= 1 / 16 + 1 / 32 + 0.2 / 32</p>

<p>= 1 / 16 + 1 / 32 + 1.6 / 2<sup>8</sup></p>

<p>= 1 / 2<sup>4</sup> + 1 / 2<sup>5</sup> + 1 / 2<sup>8</sup> + 0.6 / 2<sup>8</sup></p>

<p>= &hellip;</p>

<p>第 6 步又回到了第 2 步一样的分子 0.6 ，所以这是一个无限循环小数</p>

<p>0.1 = 0.00011001 00011001 00011001 00011001&hellip;</p>

<h1>场景</h1>

<h2><em>Puzzle 2</em></h2>

<pre><code class="java">    public static void main(String args[]) {
        System.out.println(2.00 - 1.10);    // 0.8999999999999999
    }
</code></pre>

<p>这个简单的算式得到的结果不是期望的 0.9 ，而是 0.8999999999999999 。因为 1.1 不能被精确的保存为 <code>double</code> 类型，而被保存为了最接近 1.1 的值，不幸的是，这个值与 2.0 做减法运算后得到的不是最接近 0.9 的 <code>double</code> 值，而是输出的这个奇葩数。</p>

<pre><code class="java">    public static void main(String args[]) {
        System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10")));    // 0.90
    }
</code></pre>

<p><strong>秘籍</strong>：需要精确表示时，用 <code>BigDecimal(String str)</code> ，永远不要用浮点数做运算。</p>

<h2><em>Puzzle 28: Looper</em></h2>

<pre><code class="java">    while (i == i + 1) {

    }
</code></pre>

<p>给 <code>i</code> 一个声明，使上面的语句进入无限循环状态。。</p>

<pre><code class="java">    double i = 1.0 / 0.0;
    // Better yet, you can take advantage of a constant that is provided for you by the standard libraries:
    double i = Double.POSITIVE_INFINITY;
    // In fact, any sufficiently large floating-point value will do; for example:
    double i = 1.0e40;
</code></pre>

<p>无穷大不用说。因为浮点数不能精确保存值，当一个数很大时，它的后继邻接数 <em>(ulp)</em> 与其差值可以大于 1 。</p>

<p><blockquote><p>The distance between adjacent floating-point values is called an ulp, which is an acronym for unit in the last place. In release 5.0, the Math.ulp method was introduced to calculate the ulp of a float or double value.</p></blockquote></p>

<p><strong>秘籍：不要用浮点数做循环索引。</strong></p>

<h2><em>Puzzle 87: Strained Relations</em></h2>

<p>数学上对于 <code>=</code> 的定义满足相等关系 <em>(equivalence relation)</em> 的三个条件</p>

<ul>
<li>自反性：x ~ x for all x.</li>
<li>对称性：if x ~ y, then y ~ x.</li>
<li>传递性：if x ~ y and y ~ z, then x ~ z.</li>
</ul>


<p>那么 <em>Java</em> 中的 <code>==</code> 呢</p>

<pre><code class="java">    public static void main(String[] args) throws Exception {
        // 自反性不满足
        System.out.println(Double.NaN == Double.NaN);   // false

        // 传递性不满足
        long x = Long.MAX_VALUE;
        double y = (double)Long.MAX_VALUE;
        long z = Long.MAX_VALUE - 1;
        System.out.print((x == y) + " ");   // Imprecise! true
        System.out.print((y == z) + " ");   // Imprecise! true
        System.out.println(x == z);         // Precise    false

        // 对称性满足
    }
</code></pre>

<h1>总结</h1>

<p>注意浮点数的精度丢失以及类型转换，相对于 <code>float</code> ，优先用 <code>double</code> 。</p>

<h1>引用</h1>

<ul>
<li><a href="http://www.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">IEEE Standard 754</a></li>
<li><a href="http://book.douban.com/subject/1328664/">Java Puzzlers</a></li>
<li><a href="http://justjavac.iteye.com/blog/1073775">学习 Java 浮点数必看文章</a></li>
<li><a href="http://hujiantao224.iteye.com/blog/727155">Java 浮点数表示详解</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
